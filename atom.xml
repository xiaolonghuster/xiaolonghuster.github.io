<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NO WAY OUT | 无往不前</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiaolong.li/"/>
  <updated>2021-08-15T16:21:59.296Z</updated>
  <id>http://xiaolong.li/</id>
  
  <author>
    <name>xiaolong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 持久化机制</title>
    <link href="http://xiaolong.li/2021/08/15/Redis-Persistence/"/>
    <id>http://xiaolong.li/2021/08/15/Redis-Persistence/</id>
    <published>2021-08-15T15:15:23.000Z</published>
    <updated>2021-08-15T16:21:59.296Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis 是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好 Redis 还为我们提供了持久化的机制，分别是 RDB(Redis DataBase) 和 AOF(Append Only File)。</p><h4 id="持久化流程"><a href="#持久化流程" class="headerlink" title="持久化流程"></a>持久化流程</h4><p>Redis 的数据持久化就是可以将数据保存在磁盘上，主要有下面五个过程：</p><blockquote><p>（1）客户端向服务端发送写操作(数据在客户端的内存中)。</p><p>（2）数据库服务端接收到写请求的数据(数据在服务端的内存中)。</p><p>（3）服务端调用 write 这个系统调用，将数据往磁盘上写(数据在系统内存的缓冲区中)。</p><p>（4）操作系统将缓冲区中的数据转移到磁盘控制器上(数据在磁盘缓存中)。</p><p>（5）磁盘控制器将数据写到磁盘的物理介质中(数据真正落到磁盘上)。</p></blockquote><a id="more"></a><p>这 5 个过程是在理想条件下一个正常的保存流程，但是在大多数情况下，我们的机器等等都会有各种各样的故障，这里划分了两种情况：</p><blockquote><p>（1）Redis 数据库发生故障，只要在上面的第三步执行完毕，那么就可以持久化保存，剩下的两步由操作系统替我们完成。</p><p>（2）操作系统发生故障，必须上面 5 步都完成才可以。</p></blockquote><p>在这里只考虑了保存的过程可能发生的故障，其实保存的数据也有可能发生损坏，需要一定的恢复机制，不过在这里就不再延伸了。现在主要考虑的是 Redis 如何来实现上面 5 个保存磁盘的步骤。它提供了两种策略机制，也就是 RDB 和 AOF。</p><h4 id="RDB-机制"><a href="#RDB-机制" class="headerlink" title="RDB 机制"></a>RDB 机制</h4><p>RDB 其实就是把数据以快照的形式保存在磁盘上。什么是快照呢? 你可以理解成把当前时刻的数据拍成一张照片保存下来。</p><p>RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为 dump.rdb。</p><blockquote class="blockquote-center"><p>在安装了 Redis 之后，所有的配置都是在 redis.conf 文件中，里面保存了 RDB 和 AOF 两种持久化机制的各种配置</p></blockquote><p>既然 RDB 机制是通过把某个时刻的所有数据生成一个快照来保存，那么就应该有一种触发机制，是实现这个过程。对于 RDB 来说，提供了三种机制：save、bgsave、自动化。</p><h5 id="save-触发方式"><a href="#save-触发方式" class="headerlink" title="save 触发方式"></a>save 触发方式</h5><p>该命令会阻塞当前 Redis 服务器，执行 save 命令期间，Redis 不能处理其他命令，直到 RDB 过程完成为止。具体流程如下：</p><p><img src="/images/redis/2021-08-15-save-cmd.jpeg" alt="image" title="save命令"></p><p>执行完成时候如果存在老的 RDB 文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p><h5 id="bgsave-触发方式"><a href="#bgsave-触发方式" class="headerlink" title="bgsave 触发方式"></a>bgsave 触发方式</h5><p>执行该命令时，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p><p><img src="/images/redis/2021-08-15-bgsave-cmd.jpeg" alt="image" title="bgsave命令"></p><p>具体操作是 Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。基本上 Redis 内部所有的 RDB 操作都是采用 bgsave 命令。</p><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>自动触发是由配置文件来完成的。在 redis.conf 配置文件中，有如下配置可以设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1、save：这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</span><br><span class="line">默认如下配置：</span><br><span class="line"></span><br><span class="line">&apos;#&apos;  表示900 秒内如果至少有1个key的值发生变化，则保存save 900 </span><br><span class="line">&apos;1#&apos;  表示300 秒内如果至少有10个key的值变化，则保存save 300 </span><br><span class="line">&apos;10#&apos; 表示60 秒内如果至少有10000个key的值变化，则保存save 60 10000</span><br><span class="line"></span><br><span class="line">不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 2、&apos;stop-writes-on-bgsave-error&apos;：默认值为yes。当启用了RDB且最后一次后台保存数据失败时，Redis是否停止接收数据，这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</span><br><span class="line">&gt;</span><br><span class="line">&gt; 3、&apos;rdbcompression&apos;：默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 4、&apos;rdbchecksum&apos;：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 5、&apos;dbfilename&apos;：设置快照的文件名，默认是 dump.rdb</span><br><span class="line">&gt;</span><br><span class="line">&gt; 6、&apos;dir&apos;：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</span><br></pre></td></tr></table></figure><p>可以修改这些配置来实现我们想要的效果。因为第三种方式是配置的，所以对前两种进行一个对比：</p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO 类型</td><td>同步</td><td>异步</td></tr><tr><td>是否阻塞</td><td>是</td><td>是（阻塞发生在 fork 时）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要 fork ，消耗内存</td></tr></tbody></table><h4 id="RDB-的优势和劣势"><a href="#RDB-的优势和劣势" class="headerlink" title="RDB 的优势和劣势"></a>RDB 的优势和劣势</h4><p><strong>优势</strong> ：</p><blockquote><p>（1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p><p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p><p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p></blockquote><p><strong>劣势</strong>：</p><p>RDB 快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p><h4 id="AOF-机制"><a href="#AOF-机制" class="headerlink" title="AOF 机制"></a>AOF 机制</h4><p>全量备份总是耗时的，提供一种更加高效的方式 AOF，工作机制很简单，Redis 会将每一个收到的写命令都通过 write 函数追加到文件中。通俗的理解就是日志记录。</p><h5 id="持久化原理"><a href="#持久化原理" class="headerlink" title="持久化原理"></a>持久化原理</h5><p><img src="/images/redis/2021-08-15-aof-persistence.jpeg" alt="image" title="AOF 运行原理"></p><p>每当有一个写命令过来时，就直接保存在我们的 AOF 文件中。</p><h5 id="文件重写原理"><a href="#文件重写原理" class="headerlink" title="文件重写原理"></a>文件重写原理</h5><p>AOF 的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩 aof 的持久化文件。Redis提供了 bgrewriteaof 命令。将内存中的数据以命令的方式保存到临时文件中，同时会 fork 出一条新进程来将文件重写。</p><p><img src="/images/redis/2021-08-15-aof-rewrite-file.jpeg" alt="image" title="AOF文件重写原理"></p><p>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似。</p><h5 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h5><p>AOF 也有三种触发机制，always、everysec、和 no。</p><blockquote><p>（1）每修改同步 always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p><p>（2）每秒同步 everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</p><p>（3）不同 no：从不同步</p></blockquote><p>三种触发机制对比：</p><table><thead><tr><th>命令</th><th>always</th><th>everysec</th><th>no</th></tr></thead><tbody><tr><td>优点</td><td>不丢失数据</td><td>每秒一次 fsync <br> 最大丢一秒数据</td><td>不用运维</td></tr><tr><td>缺点</td><td>IO 开销较大<br>一般的 SATA 盘只有几百 TPS</td><td>丢一秒数据</td><td>不可控</td></tr></tbody></table><h5 id="AOF-的优势和劣势"><a href="#AOF-的优势和劣势" class="headerlink" title="AOF 的优势和劣势"></a>AOF 的优势和劣势</h5><p><strong>优势</strong>：</p><blockquote><p>（1）AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒通过一个后台线程执行一次 fsync 操作，最多丢失 1 秒钟的数据。</p><p>（2）AOF 日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p><p>（3）AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p><p>（4）AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。</p></blockquote><p><strong>劣势</strong>：</p><blockquote><p>（1）对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</p><p>（2）AOF 开启后，支持的写 QPS 会比 RDB 支持的低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的</p><p>（3）AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</p></blockquote><h4 id="RDB和AOF到底该如何选择"><a href="#RDB和AOF到底该如何选择" class="headerlink" title="RDB和AOF到底该如何选择"></a>RDB和AOF到底该如何选择</h4><p>一般根据需求不同选择的也不通，但是通常都是结合使用。总结：</p><table><thead><tr><th>命令</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>宕机容易丢数据</td><td>根据策略决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好 Redis 还为我们提供了持久化的机制，分别是 RDB(Redis DataBase) 和 AOF(Append Only File)。&lt;/p&gt;
&lt;h4 id=&quot;持久化流程&quot;&gt;&lt;a href=&quot;#持久化流程&quot; class=&quot;headerlink&quot; title=&quot;持久化流程&quot;&gt;&lt;/a&gt;持久化流程&lt;/h4&gt;&lt;p&gt;Redis 的数据持久化就是可以将数据保存在磁盘上，主要有下面五个过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）客户端向服务端发送写操作(数据在客户端的内存中)。&lt;/p&gt;
&lt;p&gt;（2）数据库服务端接收到写请求的数据(数据在服务端的内存中)。&lt;/p&gt;
&lt;p&gt;（3）服务端调用 write 这个系统调用，将数据往磁盘上写(数据在系统内存的缓冲区中)。&lt;/p&gt;
&lt;p&gt;（4）操作系统将缓冲区中的数据转移到磁盘控制器上(数据在磁盘缓存中)。&lt;/p&gt;
&lt;p&gt;（5）磁盘控制器将数据写到磁盘的物理介质中(数据真正落到磁盘上)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://xiaolong.li/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://xiaolong.li/tags/redis/"/>
    
      <category term="rdb" scheme="http://xiaolong.li/tags/rdb/"/>
    
      <category term="aof" scheme="http://xiaolong.li/tags/aof/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现消息队列</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Message-queue/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Message-queue/</id>
    <published>2021-08-12T08:08:26.000Z</published>
    <updated>2021-08-12T08:09:53.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现配置中心</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Configuration/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Configuration/</id>
    <published>2021-08-12T08:07:50.000Z</published>
    <updated>2021-08-12T08:09:23.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现注册中心</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Registry/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Registry/</id>
    <published>2021-08-12T08:05:44.000Z</published>
    <updated>2021-08-12T08:10:07.691Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现分布式事务</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Distributed-transaction/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Distributed-transaction/</id>
    <published>2021-08-12T08:04:04.000Z</published>
    <updated>2021-08-12T08:09:36.933Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现分布式锁</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Distributed-lock/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Distributed-lock/</id>
    <published>2021-08-12T08:03:23.000Z</published>
    <updated>2021-08-12T08:09:21.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现负载均衡</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Load-balancing/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Load-balancing/</id>
    <published>2021-08-12T08:03:01.000Z</published>
    <updated>2021-08-12T08:09:45.165Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebRTC 中的 RTP 及 RTCP 介绍</title>
    <link href="http://xiaolong.li/2021/08/12/Introduction-RTP-RTCP-in-WebRTC/"/>
    <id>http://xiaolong.li/2021/08/12/Introduction-RTP-RTCP-in-WebRTC/</id>
    <published>2021-08-12T02:22:05.000Z</published>
    <updated>2021-08-12T07:42:04.617Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>WebRTC 技术是激烈的开放的 Web 战争中一大突破。- Brendan Eich, inventor of Java</p></blockquote><h4 id="UDP-还是-TCP？"><a href="#UDP-还是-TCP？" class="headerlink" title="UDP 还是 TCP？"></a>UDP 还是 TCP？</h4><p>如果抛开 WebRTC，让你自己实现一套实时互动直播系统，在选择网络传输协议时，你会选择使用 UDP 协议还是 TCP 协议呢？</p><p>这个问题在 2011 年至 2012 年一直是一件困扰着我们整个团队的大事儿，因为当时在国内很少有用 UDP 作为底层传输协议的。UDP 虽然传输快，但不可靠，尤其是在用户的网络质量很差的情况下，基本无法保障音视频的服务质量。</p><p>当时能想到的解决方案是，如果采用 UDP 作为底层传输协议，那就使用 RUDP（可靠性 UDP），只有这样才能保障传输过程中不丢包。但有人提出反对意见，认为如果想不丢包，就该使用 TCP，因为 RUDP 可靠性做到极致就变成 TCP 了，那为什么不直接使用 TCP 呢？</p><p>面对这种情况，2019 年的你会做何种选择呢？UDP 还是 TCP？你能拿出让人真正信服的理由吗？</p><p>现在让我告诉你正确答案：<strong>必须使用 UDP，必须使用 UDP，必须使用 UDP</strong>，重要的事情说三遍。</p><a id="more"></a><p>为什么一定要使用 UDP 呢？关于这个问题，你可以反向思考下，假如使用 TCP 会怎样呢？在极端网络情况下，TCP 为了传输的可靠性，它是如何做的呢？简单总结起来就是“发送 -&gt; 确认；超时 -&gt; 重发”的反复过程。</p><p>举个例子，A 与 B 通讯，A 首先向 B 发送数据，并启动一个定时器。当 B 收到 A 的数据后，B 需要给 A 回一个 ACK（确认）消息，反复这样操作，数据就源源不断地从 A 流向了 B。如果因为某些原因，A 一直收不到 B 的确认消息会怎么办呢？当 A 的定时器超时后，A 将重发之前没有被确认的消息，并重新设置定时器。</p><p>在 TCP 协议中，为了避免重传次数过多，定时器的超时时间会按 2 的指数增长。也就是说，假设第一次设置的超时时间是 1 秒，那么第二次就是 2 秒，第三次是 4 秒……第七次是 64 秒。如果第七次之后仍然超时，则断开 TCP 连接。你可以计算一下，从第一次超时，到最后断开连接，这之间一共经历了 2 分 07 秒，是不是很恐怖？</p><p>如果遇到前面的情况，A 与 B 之间的连接断了，那还算是个不错的情况，因为还可以再重新建立连接。但如果在第七次重传后，A 收到了 B 的 ACK 消息，那么 A 与 B 之间的数据传输的延迟就达到 1 分钟以上。对于这样的延迟，实时互动的直播系统是根本无法接受的。</p><p>基于以上的原因，在实现 <strong>实时互动直播系统的时候你必须使用 UDP 协议</strong> 。</p><h4 id="RTP-amp-RTCP"><a href="#RTP-amp-RTCP" class="headerlink" title="RTP &amp; RTCP"></a>RTP &amp; RTCP</h4><p>一般情况下，在实时互动直播系统传输音视频数据流时，我们并不直接将音视频数据流交给 UDP 传输，而是先给音视频数据加个 RTP 头，然后再交给 UDP 进行传输。为什么要这样做呢？</p><p>我们以视频帧为例，一个 I 帧的数据量是非常大的，最少也要几十 K（I/P/B 帧的概念我在前面《03 | 如何使用浏览器给自己拍照呢?》的文章中有过介绍）。而以太网的最大传输单元是多少呢？ 1.5K，所以要传输一个 I 帧需要几十个包。并且这几十个包传到对端后，还要重新组装成 I 帧，这样才能进行解码还原出一幅幅的图像。如果是我们自己实现的话，要完成这样的过程，至少需要以下几个标识。</p><blockquote><p>序号：用于标识传输包的序号，这样就可以知道这个包是第几个分片了。</p><p>起始标记：记录分帧的第一个 UDP 包。</p><p>结束标记：记录分帧的最后一个 UDP 包。</p></blockquote><p>有了上面这几个标识字段，我们就可以在发送端进行拆包，在接收端将视频帧重新再组装起来了。</p><h5 id="RTP-协议"><a href="#RTP-协议" class="headerlink" title="RTP 协议"></a>RTP 协议</h5><p>其实，这样的需求在很早之前就已经有了。因此，人们专门定义了一套规范，它就是 RTP 协议。下面让我们来详细看一下 RTP 协议吧。</p><p>如图所示，RTP 协议非常简单，我这里按字段的重要性从高往低的顺序讲解一下。</p><blockquote><p><strong>sequence number</strong>：序号，用于记录包的顺序。这与上面我们自己实现拆包、组包是同样的道理。</p><p><strong>timestamp</strong>：时间戳，同一个帧的不同分片的时间戳是相同的。这样就省去了前面所讲的 <strong>起始标记</strong> 和 <strong>结束标记</strong>。一定要记住，<strong>不同帧的时间戳肯定是不一样的</strong>。</p><p><strong>PT</strong>：Payload Type，数据的负载类型。音频流的 PT 值与视频的 PT 值是不同的，通过它就可以知道这个包存放的是什么类型的数据。</p><p>……</p></blockquote><p>这里，我并没有将 RTP 协议头中的所有字段的详细说明都列在这儿，如果你想了解所有字段的含义，可以到参考一节查看其他字段的含义。需要注意的是，这里没有将它们列出来并不代表它们不重要。恰恰相反，如果你想做音视频传输相关的工作，RTP 头中的每个字段的含义你都必须全部清楚。</p><p>知道了上面这些字段的含义后，下面我们还是来看一个具体的例子吧！假设你从网上接收到一组音视频数据，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:13,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:14,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:14,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:15,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:15,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:16,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:16,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:17,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:17,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:18,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:18,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:19,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:19,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:20,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=1,PT:98,seq:20,ts:1122334455,ssrc=2345&#125;,</span><br></pre></td></tr></table></figure><p>假设 PT=98 是视频数据，PT=111 是音频数据，那么按照上面的规则你是不是很容易就能将视频帧组装起来呢？</p><h5 id="RTCP-协议"><a href="#RTCP-协议" class="headerlink" title="RTCP 协议"></a>RTCP 协议</h5><p>在使用 RTP 包传输数据时，难免会发生丢包、乱序、抖动等问题，下面我们来看一下使用的网络一般都会在什么情况下出现问题：</p><blockquote><p>网络线路质量问题引起丢包率高;</p><p>传输的数据超过了带宽的负载引起的丢包问题;</p><p>信号干扰（信号弱）引起的丢包问题;</p><p>跨运营商引入的丢包问题;</p><p>……</p></blockquote><p>WebRTC 对这些问题在底层都有相应的处理策略，但在处理这些问题之前，它首先要让各端都知道它们自己的网络质量到底是怎样的，这就是 RTCP 的作用。</p><p><strong>RTCP 有两个最重要的报文：RR（Reciever Report）和 SR(Sender Report)。通过这两个报文的交换，各端就知道自己的网络质量到底如何了。</strong></p><p>RTCP 支持的所有报文及其含义可以查看文章最后所附的参考一节。这里我们以 SR 报文为例，看看 SR 报文中都包括哪些信息。</p><p>下面我就简要说明一下该报文中字段的含义：</p><blockquote><p>V=2，指报文的版本。</p><p>P，表示填充位，如果该位置 1，则在 RTCP 报文的最后会有填充字节（内容是按字节对齐的）。</p><p>RC，全称 Report Count，指 RTCP 报文中接收报告的报文块个数。</p><p>PT=200，Payload Type，也就是说 SR 的值为 200。</p><p>……</p></blockquote><p>与 RTP 协议头一样，上面只介绍了 RTCP 头字段的含义，至于其他每个字段的含义请查看参考一节。同样的，对于 RTCP 头中的每个字段也必须都非常清楚，只有这样以后你在看 WebRTC 带宽评估相关的代码时，才不至于晕头转向。从上图中我们可以了解到，SR 报文分成三部分：Header、Sender info 和 Report block。在 NTP 时间戳之上的部分为 SR 报文的 Header 部分，SSRC_1 字段之上到 Header 之间的部分为 Sender info 部分，剩下的就是一个一个的 Report Block 了。那这每一部分是用于干什么的呢？</p><blockquote><p>Header 部分用于标识该报文的类型，比如是 SR 还是 RR。</p><p>Sender info 部分用于指明作为发送方，到底发了多少包。</p><p>Report block 部分指明发送方作为接收方时，它从各个 SSRC 接收包的情况。</p></blockquote><p>通过以上的分析，你可以发现 SR 报文并不仅是指发送方发了多少数据，它还报告了作为接收方，它接收到的数据的情况。当发送端收到对端的接收报告时，它就可以根据接收报告来评估它与对端之间的网络质量了，随后再根据网络质量做传输策略的调整。</p><p><strong>SR</strong> 报文与 <strong>RR</strong> 报文无疑是 RTCP 协议中最重要的两个报文，不过 RTCP 中的其他报文也都非常重要的，如果你想学好 WebRTC ，那么 RTCP 中的每个报文你都必须掌握。</p><p>比如，RTCP 类型为 206、子类型为 4 的 FIR 报文，其含义是 Full Intra Request (FIR) Command，即 <strong>完整帧请求</strong> 命令。它起什么作用？又在什么时候使用呢？</p><p>该报文也是一个特别关键的报文，我为什么这么说呢？试想一下，在一个房间里有 3 个人进行音视频聊天，然后又有一个人加入到房间里，这时如果不做任何处理的话，那么第四个人进入到房间后，在一段时间内很难直接看到其他三个人的视频画面了，这是为什么呢？</p><p>原因就在于解码器在解码时有一个上下文。在该上下文中，必须先拿到一个 IDR 帧之后才能将其后面的 P 帧、B 帧进行解码。也就是说，在没有 IDR 帧的情况下，对于收到的 P 帧、B 帧解码器只能干瞪眼了。</p><p>如何解决这个问题呢？这就引出了 FIR 报文。当第四个人加入到房间后，它首先发送 FIR 报文，当其他端收到该报文后，便立即产生各自的 IDR 帧发送给新加入的人，这样当新加入的人拿到房间中其他的 IDR 帧后，它的解码器就会解码成功，于是其他人的画面也就一下子全部展示出来了。所以你说它是不是很重要呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;WebRTC 技术是激烈的开放的 Web 战争中一大突破。- Brendan Eich, inventor of Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;UDP-还是-TCP？&quot;&gt;&lt;a href=&quot;#UDP-还是-TCP？&quot; class=&quot;headerlink&quot; title=&quot;UDP 还是 TCP？&quot;&gt;&lt;/a&gt;UDP 还是 TCP？&lt;/h4&gt;&lt;p&gt;如果抛开 WebRTC，让你自己实现一套实时互动直播系统，在选择网络传输协议时，你会选择使用 UDP 协议还是 TCP 协议呢？&lt;/p&gt;
&lt;p&gt;这个问题在 2011 年至 2012 年一直是一件困扰着我们整个团队的大事儿，因为当时在国内很少有用 UDP 作为底层传输协议的。UDP 虽然传输快，但不可靠，尤其是在用户的网络质量很差的情况下，基本无法保障音视频的服务质量。&lt;/p&gt;
&lt;p&gt;当时能想到的解决方案是，如果采用 UDP 作为底层传输协议，那就使用 RUDP（可靠性 UDP），只有这样才能保障传输过程中不丢包。但有人提出反对意见，认为如果想不丢包，就该使用 TCP，因为 RUDP 可靠性做到极致就变成 TCP 了，那为什么不直接使用 TCP 呢？&lt;/p&gt;
&lt;p&gt;面对这种情况，2019 年的你会做何种选择呢？UDP 还是 TCP？你能拿出让人真正信服的理由吗？&lt;/p&gt;
&lt;p&gt;现在让我告诉你正确答案：&lt;strong&gt;必须使用 UDP，必须使用 UDP，必须使用 UDP&lt;/strong&gt;，重要的事情说三遍。&lt;/p&gt;
    
    </summary>
    
      <category term="WebRTC" scheme="http://xiaolong.li/categories/WebRTC/"/>
    
    
      <category term="RTP" scheme="http://xiaolong.li/tags/RTP/"/>
    
      <category term="RTCP" scheme="http://xiaolong.li/tags/RTCP/"/>
    
      <category term="WebRTC" scheme="http://xiaolong.li/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>正向代理和反向代理的区别</title>
    <link href="http://xiaolong.li/2021/02/19/The-difference-between-forward-and-reverse-proxy/"/>
    <id>http://xiaolong.li/2021/02/19/The-difference-between-forward-and-reverse-proxy/</id>
    <published>2021-02-19T05:32:50.000Z</published>
    <updated>2021-08-07T16:32:49.023Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="什么是代理？"><a href="#什么是代理？" class="headerlink" title="什么是代理？"></a>什么是代理？</h4><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。<br>刚开始的时候，代理多数是帮助内网client访问外网server用的，后来出现了反向代理，”反向”的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内。</p><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理类似一个跳板机，代理访问外部资源</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了</p><p><a href="https://www.cnblogs.com/taostaryu/p/10547132.html" target="_blank" rel="noopener">https://www.cnblogs.com/taostaryu/p/10547132.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="正向代理" scheme="http://xiaolong.li/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="反向代理" scheme="http://xiaolong.li/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="Nginx" scheme="http://xiaolong.li/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux国内各大源站</title>
    <link href="http://xiaolong.li/2021/01/18/internal-linux-mirrors-website/"/>
    <id>http://xiaolong.li/2021/01/18/internal-linux-mirrors-website/</id>
    <published>2021-01-18T02:14:49.000Z</published>
    <updated>2021-08-15T16:16:16.960Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="企业源："><a href="#企业源：" class="headerlink" title="企业源："></a>企业源：</h5><p>阿里云开源镜像站： <a href="http://mirrors.aliyun.com/" target="_blank" rel="noopener">http://mirrors.aliyun.com/</a><br>搜狐开源镜像站：<a href="http://mirrors.sohu.com/" target="_blank" rel="noopener">http://mirrors.sohu.com/</a><br>网易开源镜像站：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></p><a id="more"></a><h5 id="教育源："><a href="#教育源：" class="headerlink" title="教育源："></a>教育源：</h5><p>重庆大学：<br><a href="http://mirrors.cqu.edu.cn/" target="_blank" rel="noopener">http://mirrors.cqu.edu.cn/</a><br>北京理工大学：<br><a href="http://mirror.bit.edu.cn" target="_blank" rel="noopener">http://mirror.bit.edu.cn</a> (IPv4 only)<br><a href="http://mirror.bit6.edu.cn" target="_blank" rel="noopener">http://mirror.bit6.edu.cn</a> (IPv6 only)<br>北京交通大学：<br><a href="http://mirror.bjtu.edu.cn" target="_blank" rel="noopener">http://mirror.bjtu.edu.cn</a> (IPv4 only)<br><a href="http://mirror6.bjtu.edu.cn" target="_blank" rel="noopener">http://mirror6.bjtu.edu.cn</a> (IPv6 only)<br><a href="http://debian.bjtu.edu.cn" target="_blank" rel="noopener">http://debian.bjtu.edu.cn</a> (IPv4+IPv6)<br>兰州大学：<a href="http://mirror.lzu.edu.cn/" target="_blank" rel="noopener">http://mirror.lzu.edu.cn/</a><br>厦门大学：<a href="http://mirrors.xmu.edu.cn/" target="_blank" rel="noopener">http://mirrors.xmu.edu.cn/</a><br>上海交通大学：<br><a href="http://ftp.sjtu.edu.cn/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/</a> (IPv4 only)<br><a href="http://ftp6.sjtu.edu.cn" target="_blank" rel="noopener">http://ftp6.sjtu.edu.cn</a> (IPv6 only)<br>清华大学：<br><a href="http://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors.6.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.6.tuna.tsinghua.edu.cn/</a> (IPv6 only)<br><a href="http://mirrors.4.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.4.tuna.tsinghua.edu.cn/</a> (IPv4 only)<br>天津大学：<a href="http://mirror.tju.edu.cn/" target="_blank" rel="noopener">http://mirror.tju.edu.cn/</a><br>中国科学技术大学：<br><a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors4.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors4.ustc.edu.cn/</a><br><a href="http://mirrors6.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors6.ustc.edu.cn/</a><br>西南大学：<a href="http://linux.swu.edu.cn/swudownload/Distributions/" target="_blank" rel="noopener">http://linux.swu.edu.cn/swudownload/Distributions/</a><br>东北大学：<br><a href="http://mirror.neu.edu.cn/" target="_blank" rel="noopener">http://mirror.neu.edu.cn/</a> (IPv4 only)<br><a href="http://mirror.neu6.edu.cn/" target="_blank" rel="noopener">http://mirror.neu6.edu.cn/</a> (IPv6 only)<br>电子科技大学：<a href="http://ubuntu.uestc.edu.cn/" target="_blank" rel="noopener">http://ubuntu.uestc.edu.cn/</a><br>青岛大学：<a href="http://mirror.qdu.edu.cn/" target="_blank" rel="noopener">http://mirror.qdu.edu.cn/</a><br>开源中国社区 <a href="http://mirrors.oss.org.cn/" target="_blank" rel="noopener">http://mirrors.oss.org.cn/</a><br>大连东软信息学院 <a href="http://mirrors.neusoft.edu.cn/" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/</a><br>华中科技大学 <a href="http://mirrors.hust.edu.cn/" target="_blank" rel="noopener">http://mirrors.hust.edu.cn/</a><br>中山大学 <a href="http://mirrors.sysu.edu.cn/" target="_blank" rel="noopener">http://mirrors.sysu.edu.cn/</a><br>清华大学学生网管会 <a href="http://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/</a><br>浙江大学 <a href="http://mirrors.zju.edu.cn/web/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/web/</a></p><p>台湾淡江大学 <a href="http://ftp.tku.edu.tw/Linux/" target="_blank" rel="noopener">http://ftp.tku.edu.tw/Linux/</a></p><p>Linux运维派开源镜像 <a href="http://mirrors.skyshe.cn/" target="_blank" rel="noopener">http://mirrors.skyshe.cn/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;企业源：&quot;&gt;&lt;a href=&quot;#企业源：&quot; class=&quot;headerlink&quot; title=&quot;企业源：&quot;&gt;&lt;/a&gt;企业源：&lt;/h5&gt;&lt;p&gt;阿里云开源镜像站： &lt;a href=&quot;http://mirrors.aliyun.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.aliyun.com/&lt;/a&gt;&lt;br&gt;搜狐开源镜像站：&lt;a href=&quot;http://mirrors.sohu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.sohu.com/&lt;/a&gt;&lt;br&gt;网易开源镜像站：&lt;a href=&quot;http://mirrors.163.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.163.com/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kafka-Cluster-building</title>
    <link href="http://xiaolong.li/2020/11/11/Kafka-Cluster-building/"/>
    <id>http://xiaolong.li/2020/11/11/Kafka-Cluster-building/</id>
    <published>2020-11-11T11:06:08.000Z</published>
    <updated>2021-08-07T16:32:49.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://cloud.tencent.com/developer/article/1023898" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1023898</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>zookeeper集群搭建</title>
    <link href="http://xiaolong.li/2020/11/11/Zookeeper-Cluster-building/"/>
    <id>http://xiaolong.li/2020/11/11/Zookeeper-Cluster-building/</id>
    <published>2020-11-11T11:05:30.000Z</published>
    <updated>2021-08-07T16:32:49.024Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="为什么-zookeeper-集群的节点数是奇数"><a href="#为什么-zookeeper-集群的节点数是奇数" class="headerlink" title="为什么 zookeeper 集群的节点数是奇数"></a>为什么 zookeeper 集群的节点数是奇数</h4><p>zookeeper 集群通常是用来对用户的分布式应用程序提供协调服务的，为了保证数据的一致性，对 zookeeper 集群进行了这样三种角色划分：leader、follower、observer分别对应着主、从、观察者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leader : 负责进行投票的发起和决议，更新系统状态。</span><br><span class="line">follower : 用于接收客户端请求并向客户端返回结果以及在选举过程中参与投票。</span><br><span class="line">observer : 通常是针对于查询操作做负载的。 observer 与 follower 节点最大的不同在于 observer 没有投票权，在客户端发起的增删改操中， leader 节点是不会把消息传递给 observer 让其投票的。但是查询操作跟 follower 一样，客户端的查询到了 observer 节点， observer 节点会去访问 leader 节点取最新的数据然后返回给客户端。</span><br></pre></td></tr></table></figure><p>集群可以保证在每台机器数据保持一致的情况下，客户端每次发起的查询操作，集群节点都能返回同样的结果。但是对于客户端发起的增、删、改等能改变数据的操作，如果集群中的多台机器各自修改数据，那么就无法保证数据的一致性。</p><p>那么，对于增、删、改操作， zookeeper 集群规定只有 leader 节点才有权利去执行修改数据的操作，而 follower 节点即使接收到客户端发起的数据修改操作，也要将其转交给 leader 来处理， leader节点接收到修改数据的请求后，会向所有 follower 节点广播一条消息，让其执行操作， follower 节点执行完后，需要向 leader 节点回复执行结果。当 leader 节点收到半数以上的 follower 节点的确认消息后，便会判定该操作执行完毕，然后向所有 follower 节点广播该操作已经生效。</p><p>所以在 zookeeper 集群中， leader 节点是不可缺少的， leader 节点也是由所有 follower 节点选举产生，而且只有一个。</p><p>//todo leader节点选取逻辑</p><blockquote><p>zookeeper 集群中 leader 的选取逻辑，要求 <strong>可用节点数量</strong> &gt; <strong>总节点数量 / 2</strong>，注意，这里是 <strong>&gt;</strong> ,并非 <strong>&gt;=</strong> 。 </p></blockquote><p>为什么集群节点数量要奇数个，主要从以下两个方面考虑。</p><h5 id="防脑裂导致集群不可用"><a href="#防脑裂导致集群不可用" class="headerlink" title="防脑裂导致集群不可用"></a>防脑裂导致集群不可用</h5><p>在一个 zookeeper 集群中，可以有多个 follower 和 observe 节点，但是有且只能有一个 leader 节点。如果 leader 节点不可用或者宕机，剩下的所有节点机器会投票产生新的 leader 节点。</p><p>集群脑裂: 一个集群由于网络不通或者其他原因分裂成多个小集群的现象。</p><h5 id="容错率和成本控制"><a href="#容错率和成本控制" class="headerlink" title="容错率和成本控制"></a>容错率和成本控制</h5><p><a href="https://www.cnblogs.com/lishiqi-blog/p/12314111.html" target="_blank" rel="noopener">https://www.cnblogs.com/lishiqi-blog/p/12314111.html</a></p><p><a href="https://www.cnblogs.com/ysocean/p/9860529.html" target="_blank" rel="noopener">https://www.cnblogs.com/ysocean/p/9860529.html</a></p><p><a href="https://blog.csdn.net/jiangxiulilinux/article/details/96433560" target="_blank" rel="noopener">https://blog.csdn.net/jiangxiulilinux/article/details/96433560</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="教程" scheme="http://xiaolong.li/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="zookeeper" scheme="http://xiaolong.li/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Introduction-to-h264-frame</title>
    <link href="http://xiaolong.li/2020/10/21/Introduction-to-h264-frame/"/>
    <id>http://xiaolong.li/2020/10/21/Introduction-to-h264-frame/</id>
    <published>2020-10-21T02:29:01.000Z</published>
    <updated>2021-08-07T16:32:49.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>同城双中心容灾简介及部署网络</title>
    <link href="http://xiaolong.li/2020/03/04/Introduction-to-Dual-Center-for-Disaster-Recovery/"/>
    <id>http://xiaolong.li/2020/03/04/Introduction-to-Dual-Center-for-Disaster-Recovery/</id>
    <published>2020-03-04T08:53:09.000Z</published>
    <updated>2021-08-07T16:32:49.020Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>同城双中心是指在同城或邻近城市建立两个可独立承担业务的数据中心，双中心具备基本相同的业务处理能力并通过高速链路实时同步数据，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下备应急切换，保证业务的持续性。异地灾备中心是指在异地的城市建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。</p><p>同城双中心的部署方式分为两种，分别为主备和双活。</p><a id="more"></a><h3 id="主备中心模型"><a href="#主备中心模型" class="headerlink" title="主备中心模型"></a>主备中心模型</h3><p>从字面含义上看，主备中心就是建设两个数据中心，一主一备，两个数据中心均具有独立承担对外提供业务的能力。正常情况下，主中心对外提供服务，当重大故障发生时，主中心的业务切换到备中心，备中心成为新的生产中心对外提供服务。</p><p>以上对主备关系的描述非常简单，但在实际部署过程中，需网络、应用、数据库等多部门协调合作，才能切换，我们今天主要谈网络。</p><h4 id="主备数据中心示意图"><a href="#主备数据中心示意图" class="headerlink" title="主备数据中心示意图"></a>主备数据中心示意图</h4><p>上图是较为典型的同城主备中心网络模型，A中心是生产中心，B中心为备中心，A、B两个中心的业务分区使用相同的IP地址段。</p><h4 id="技术关键点："><a href="#技术关键点：" class="headerlink" title="技术关键点："></a>技术关键点：</h4><blockquote><ol><li>A、B中心的网络核心（网关）进行二层打通；</li><li>网关启用在主中心一侧，备中心网关为关闭状态；</li><li>主中心A对外发布路由,B中心不对外发布路由。</li></ol></blockquote><h4 id="数据中心间切换"><a href="#数据中心间切换" class="headerlink" title="数据中心间切换"></a>数据中心间切换</h4><p>A中心停止对外发布路由,B中心，同时将A中心的网关切换至B中心，这样就完成了数据中心网络的切换。</p><h4 id="主备模型优点"><a href="#主备模型优点" class="headerlink" title="主备模型优点"></a>主备模型优点</h4><blockquote><ol><li>技术简单、切换方便；</li><li>现有双中心过渡到此模型较简单，不涉及应用IP地址改造；</li></ol></blockquote><h4 id="主备模型缺点"><a href="#主备模型缺点" class="headerlink" title="主备模型缺点"></a>主备模型缺点</h4><blockquote><ol><li>存在较多的中心间穿越流量，无法做到“本中心服务器从本中心出入”（两侧网关无法同时开启，否则会出现防火墙异步路由问题）。</li><li>中心间的物理距离过长，导致网络延迟增大，对延时敏感的应用可能会受到影响；</li><li>中心间L2打通，会使二层域扩大，一个中心二层故障可能影响到另一个中心，需做数据中心STP隔离或采用特殊技术，例如OTV；</li><li>需考虑防火墙策略如何同步的问题；</li><li>链路闲置，资源没有得到最大化利用，例如B中心对外的广域网链路。</li></ol></blockquote><h3 id="双活中心模型"><a href="#双活中心模型" class="headerlink" title="双活中心模型"></a>双活中心模型</h3><h4 id="双活中心示意图"><a href="#双活中心示意图" class="headerlink" title="双活中心示意图"></a>双活中心示意图</h4><p>双活数据中心，即两个数据中心具有同时对外提供服务的能力。如下图：</p><p>A、B两个数据中心，采用独立的IP地址段，同时对外提供服务，客户端依靠DNS的解析结果，来判断从哪个数据中心进入。</p><h4 id="技术关键点"><a href="#技术关键点" class="headerlink" title="技术关键点"></a>技术关键点</h4><blockquote><ol><li>两个中心采用独立的IP地址段，均对外发布路由；</li><li>采用DNS的方式，将客户端流量引至对应数据中心。</li></ol></blockquote><h4 id="数据中心切换"><a href="#数据中心切换" class="headerlink" title="数据中心切换"></a>数据中心切换</h4><blockquote><ol><li>正常情况下，两个数据中心同时对外提供服务；</li><li>一侧数据中心故障时，改变DNS解析，即可停止该数据中心的服务。</li></ol></blockquote><h4 id="双活数据中心优点"><a href="#双活数据中心优点" class="headerlink" title="双活数据中心优点"></a>双活数据中心优点</h4><blockquote><ol><li>两个数据中心完全独立，互不干扰；</li><li>数据中心间流量较少；</li><li>无需考虑防火墙异步路由问题；</li><li>链路得到更有效的利用，经济最大化。</li></ol></blockquote><h4 id="双活数据中心缺点"><a href="#双活数据中心缺点" class="headerlink" title="双活数据中心缺点"></a>双活数据中心缺点</h4><p>技术方面，暂时没有想到缺点。可行性上，从现有双中心过渡到双活数据中心，除IP地址改造外，还涉及应用的DNS改造，涉及部门间协同工作，驱动困难，这种模型较适合新建的数据中心。</p><p>选择数据中心网络模型，需调研业务/应用/系统/服务器的部署需求，从上到下统一考虑，最适合自己的，才是最好的。</p><p><strong><em> 无论是主备还是双活，网络层面做到各种“活”并不困难，在生产环境中，目前面临的最大瓶颈其实是双中心的数据库的“双活”问题。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同城双中心是指在同城或邻近城市建立两个可独立承担业务的数据中心，双中心具备基本相同的业务处理能力并通过高速链路实时同步数据，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下备应急切换，保证业务的持续性。异地灾备中心是指在异地的城市建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。&lt;/p&gt;
&lt;p&gt;同城双中心的部署方式分为两种，分别为主备和双活。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://xiaolong.li/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="容灾" scheme="http://xiaolong.li/tags/%E5%AE%B9%E7%81%BE/"/>
    
  </entry>
  
  <entry>
    <title>gRpc-go流模式中，服务端如何主动关闭stream</title>
    <link href="http://xiaolong.li/2020/03/02/How-to-cancel-streaming-gRPC-Send-from-server/"/>
    <id>http://xiaolong.li/2020/03/02/How-to-cancel-streaming-gRPC-Send-from-server/</id>
    <published>2020-03-02T13:19:24.000Z</published>
    <updated>2021-08-07T16:32:49.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用gRpc流模式的过程中会发现，官方API只提供了客户端关闭stream的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CloseSend closes the send direction of the stream. It closes the stream</span></span><br><span class="line"><span class="comment">// when non-nil error is met. It is also not safe to call CloseSend</span></span><br><span class="line"><span class="comment">// concurrently with SendMsg.</span></span><br><span class="line">CloseSend() error</span><br></pre></td></tr></table></figure><blockquote><p>那么在开发过程中我们是不是需要从服务端主动断开stream，如果需要，该怎么断开？</p></blockquote><a id="more"></a><p>如果你知道gRpc的底层原理，其实很好理解为什么官方不提供服务端断开的API。因为gRpc底层是通过TCP实现的 [事实上，基本上所有RPC框架默认都是使用TCP，因为RPC常用在业务系统之间进行数据交换，需要保证可靠性] ，TCP的连接建立 [三次握手] 与释放 [四次挥手] 都是由客户端发起的，所以这就是为什么服务端不支持主动断开API的原因。</p><p>但是在实际开发过程中，我们经常会遇到需要服务端主动断开的策略，如果客户端出现连接泄漏的问题，通过TCP一直连接服务端，那么势必会造成服务端的连接过多无法释放，内存上升甚至出现服务宕机的危险。</p><p>那么在开发过程中就要考虑到避免因为客户端的bug导致服务器不可用，服务端就需要有保护机制。</p><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>服务端流式的设计，需要在发送给客户端响应时告知客户端，服务端已经处理完了，就是最后一帧的概念，多久以后服务端还没有收到客户端断开的标志，那么服务断就主动发起断开。所以一般服务端流式要做到以下两点：</p><blockquote><ol><li>流结束标志</li><li>定时器（最重要）</li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong><em>Talk is cheap, Show me the code.</em></strong></p><p>proto协议设计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package protocol;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    string  msg     =   1;</span><br><span class="line">    int32   times   =   2;</span><br><span class="line">    bool    last    =   3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    string  reply   =   1;</span><br><span class="line">    int32   index   =   2;</span><br><span class="line">    bool    last    =   3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service KeJiInterface &#123;</span><br><span class="line">    rpc Say(stream Request) returns (stream Response) &#123;&#125;</span><br><span class="line">    rpc ServerStream(Request) returns (stream Response) &#123;&#125;</span><br><span class="line">    rpc ClientStream(stream Request) returns (Response) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双向流"><a href="#双向流" class="headerlink" title="双向流"></a>双向流</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="服务端单向流式"><a href="#服务端单向流式" class="headerlink" title="服务端单向流式"></a>服务端单向流式</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用gRpc流模式的过程中会发现，官方API只提供了客户端关闭stream的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// CloseSend closes the send direction of the stream. It closes the stream&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// when non-nil error is met. It is also not safe to call CloseSend&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// concurrently with SendMsg.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CloseSend() error&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;那么在开发过程中我们是不是需要从服务端主动断开stream，如果需要，该怎么断开？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="教程" scheme="http://xiaolong.li/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="gRpc" scheme="http://xiaolong.li/tags/gRpc/"/>
    
      <category term="RPC" scheme="http://xiaolong.li/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>最佳实践之 - Golang&#39;s Dockerfile</title>
    <link href="http://xiaolong.li/2020/02/13/Dockerfile-best-practices-for-golang-projects/"/>
    <id>http://xiaolong.li/2020/02/13/Dockerfile-best-practices-for-golang-projects/</id>
    <published>2020-02-13T12:58:39.000Z</published>
    <updated>2021-08-07T16:32:49.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="常用做法"><a href="#常用做法" class="headerlink" title="常用做法"></a>常用做法</h4><p>基于 golang 官方基础镜像打包，Dockerfile如下：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 golang 官方基础镜像打包</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.12</span></span><br><span class="line"></span><br><span class="line">NV GO111MODULE=on \</span><br><span class="line">    GOPROXY=https://goproxy.cn,direct </span><br><span class="line">    </span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> . .</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> go build .</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["./app"]</span><br></pre></td></tr></table></figure></p><p>但是最终 docker build 出来的镜像高达300多M, 这是由于 golang 这个基础镜像中的工具链及其依赖项（git，mercurial 等）重达几百MB，而这一部分我们在运行的时候是不需要的。</p><p>因此，我们需要对基础镜像进行精简。</p><a id="more"></a><h4 id="精简镜像"><a href="#精简镜像" class="headerlink" title="精简镜像"></a>精简镜像</h4><h5 id="使用-scratch"><a href="#使用-scratch" class="headerlink" title="使用 scratch"></a>使用 scratch</h5><p>该镜像是一个空的镜像，可以用于构建 busybox 等超小镜像，可以说是真正的从零开始构建属于自己的镜像。在此基础镜像上运行的应用程序只能访问内核，尽管Go宣称自己只需要Linux内核，但是我们在真实的项目中或多或少会有其他依赖项，比如 我们项目会用到 CGO 等等。所以在构建 Golang 项目是，一般不建议直接采用 scratch 做基础镜像，否则你需要在 Dockerfile 中手动加载很多依赖项。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 scratch 官方基础镜像打包</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br></pre></td></tr></table></figure><h5 id="使用-alpine"><a href="#使用-alpine" class="headerlink" title="使用 alpine"></a>使用 alpine</h5><p>Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，alpine 采用了 musl libc 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。</p><p>Alpine Docker 镜像也继承了 Alpine Linux 发行版的这些优势。相比于其他 Docker 镜像，它的容量非常小，仅仅只有 5 MB 左右（对比 Ubuntu 系列镜像接近 200 MB），且拥有非常友好的包管理机制。官方镜像来自 docker-alpine 项目。目前 Docker 官方已开始推荐使用 Alpine 替代之前的 Ubuntu 做为基础镜像环境。</p><p>Alpine 和其他通用 Linux 发行版对于 Golang 编译出来的可执行文件要求有所不同，Alpine 要求可执行文件必须是静态链接的可执行文件。所以在编译 Golang 时需要添加 -tags netgo ，来生成静态链接的可执行文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 alpine 官方基础镜像打包</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br></pre></td></tr></table></figure><p>但是对 C 的支持不太好。</p><p>在 Alpine Docker 镜像上运行 cgo 项目会出现问题，提示一下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: standard_init_linux.go:175: exec user process caused &quot;no such file or directory&quot;</span><br></pre></td></tr></table></figure></p><p>原因是当 cgo 开启时，默认是按照动态库的方式来链接 so 文件的，但 alpine 只支持静态链接，所以会出错。<br>解决方案有两种：</p><blockquote><p>通过设置 CGO_ENABLED=0 来解决，此时 cgo 也不可用了</p></blockquote><blockquote><p>调用 go build –ldflags “-extldflags -static” ，来让gcc使用静态编译可以解决问题</p></blockquote><h5 id="使用-ubuntu"><a href="#使用-ubuntu" class="headerlink" title="使用 ubuntu"></a>使用 ubuntu</h5><p>ubuntu 镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 ubuntu 官方基础镜像打包</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br></pre></td></tr></table></figure><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h5 id="多层构建方式"><a href="#多层构建方式" class="headerlink" title="多层构建方式"></a>多层构建方式</h5><blockquote><p>FROM golang:1.12<br>用对go功能比较齐全镜像编译源程序，生成可执行文件</p></blockquote><blockquote><p>FROM ubuntu<br>用精简镜像作为最终的容器的镜像</p></blockquote><blockquote><p>拷贝可执行文件到容器内</p></blockquote><blockquote><p>打包生成最终的镜像</p></blockquote><p>Dockerfile:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包依赖阶段使用golang作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.12</span> as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span> version="1.0" description="xiaolong.li" by="xiaolonghuster"</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用go module</span></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on \</span><br><span class="line">    GOPROXY=https://goproxy.cn,direct</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /app-pkg</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> . /app-pkg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定OS等，并go build</span></span><br><span class="line"><span class="keyword">RUN</span> GOOS=linux GOARCH=amd64 &amp;&amp; cd src &amp;&amp; go build -o app main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于不止依赖二进制文件，还依赖conf文件夹下的配置文件，将这些文件放到了publish文件夹</span></span><br><span class="line"><span class="keyword">RUN</span> mkdir publish &amp;&amp; cp src/app publish &amp;&amp; \</span><br><span class="line">    cp -r conf publish</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行阶段为精简镜像包，指定ubuntu作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上一个阶段publish文件夹下的所有文件复制进来</span></span><br><span class="line"><span class="keyword">COPY</span> --from=builder /app-pkg/publish .</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10086</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["./app"]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;常用做法&quot;&gt;&lt;a href=&quot;#常用做法&quot; class=&quot;headerlink&quot; title=&quot;常用做法&quot;&gt;&lt;/a&gt;常用做法&lt;/h4&gt;&lt;p&gt;基于 golang 官方基础镜像打包，Dockerfile如下：&lt;br&gt;&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 基于 golang 官方基础镜像打包&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; golang:&lt;span class=&quot;number&quot;&gt;1.12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NV GO111MODULE=on \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GOPROXY=https://goproxy.cn,direct &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WORKDIR&lt;/span&gt; /app&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;COPY&lt;/span&gt; . .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; go build .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;EXPOSE&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10010&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENTRYPOINT&lt;/span&gt; [&quot;./app&quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是最终 docker build 出来的镜像高达300多M, 这是由于 golang 这个基础镜像中的工具链及其依赖项（git，mercurial 等）重达几百MB，而这一部分我们在运行的时候是不需要的。&lt;/p&gt;
&lt;p&gt;因此，我们需要对基础镜像进行精简。&lt;/p&gt;
    
    </summary>
    
      <category term="最佳实践" scheme="http://xiaolong.li/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Dockerfile" scheme="http://xiaolong.li/tags/Dockerfile/"/>
    
      <category term="Golang" scheme="http://xiaolong.li/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>你必须知道的Docker镜像仓库的搭建</title>
    <link href="http://xiaolong.li/2020/02/13/Introduction-docker-repository-setup/"/>
    <id>http://xiaolong.li/2020/02/13/Introduction-docker-repository-setup/</id>
    <published>2020-02-13T12:58:39.000Z</published>
    <updated>2021-08-07T16:32:49.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="官方标配：Registry私有镜像仓库"><a href="#官方标配：Registry私有镜像仓库" class="headerlink" title="官方标配：Registry私有镜像仓库"></a>官方标配：Registry私有镜像仓库</h4><p><a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a> 作为 Docker 默认官方公共镜像，如果想要自己搭建私有镜像残酷，官方也提供 Registry 镜像，使得我们搭建私有仓库变得非常简单。</p><p>所谓私有仓库，也就是在本地（局域网）搭建的一个类似公共仓库的东西，搭建好之后，我们可以将镜像提交到私有仓库中。这样我们既能使用 Docker 来运行我们的项目镜像，也避免了商业项目暴露出去的风险。</p><a id="more"></a><h5 id="搭建镜像仓库"><a href="#搭建镜像仓库" class="headerlink" title="搭建镜像仓库"></a>搭建镜像仓库</h5><p>首先，搜索 Registry 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search registry</span><br></pre></td></tr></table></figure><p><img src="/images/docker/2020-02-13-docker-search-registry.jpg" alt="image" title="Docker搜索registry镜像"></p><p>下载 Registry 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><p><img src="/images/docker/2020-02-13-docker-pull-registry.jpg" alt="image" title="Docker拉取registry拉取"></p><p>查看本地镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/images/docker/2020-02-13-docker-images.jpg" alt="image" title="查看本地镜像"></p><p>运行一个Registry镜像仓库的容器实例，检查是否启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry registry:latest</span><br></pre></td></tr></table></figure><p>最后，在客户端查看镜像仓库中的所有镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://your-server-ip:5000/v2/_catalog</span><br></pre></td></tr></table></figure><p><img src="/images/docker/2020-02-13-docker-registry-images-null-list.jpg" alt="image" title="查看仓库镜像列表"></p><p>这里返回的json数据代表暂无任何仓库，因为我们还没有上传任何镜像。</p><h5 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push your-image-name:tagname your-server-ip:5000/your-image-name:tagname</span><br></pre></td></tr></table></figure><blockquote><p>如果不设置可信任源，又没有配置HTTPS证书，那么会遇到这个错误：error: Get <a href="https://ip:port/v1/_ping" target="_blank" rel="noopener">https://ip:port/v1/_ping</a>: http: server gave HTTP response to HTTPS client.</p></blockquote><h5 id="设置可信任源"><a href="#设置可信任源" class="headerlink" title="设置可信任源"></a>设置可信任源</h5><h5 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h5><p>下载镜像就很简单了，使用pull命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull your-server-ip:5000/your-image-name:tagname</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;官方标配：Registry私有镜像仓库&quot;&gt;&lt;a href=&quot;#官方标配：Registry私有镜像仓库&quot; class=&quot;headerlink&quot; title=&quot;官方标配：Registry私有镜像仓库&quot;&gt;&lt;/a&gt;官方标配：Registry私有镜像仓库&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://hub.docker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker Hub&lt;/a&gt; 作为 Docker 默认官方公共镜像，如果想要自己搭建私有镜像残酷，官方也提供 Registry 镜像，使得我们搭建私有仓库变得非常简单。&lt;/p&gt;
&lt;p&gt;所谓私有仓库，也就是在本地（局域网）搭建的一个类似公共仓库的东西，搭建好之后，我们可以将镜像提交到私有仓库中。这样我们既能使用 Docker 来运行我们的项目镜像，也避免了商业项目暴露出去的风险。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://xiaolong.li/tags/Docker/"/>
    
      <category term="Docker Hub" scheme="http://xiaolong.li/tags/Docker-Hub/"/>
    
      <category term="Docker Registry" scheme="http://xiaolong.li/tags/Docker-Registry/"/>
    
  </entry>
  
  <entry>
    <title>GO语言代码规范指导</title>
    <link href="http://xiaolong.li/2019/12/05/Developer-Guide-for-Golang/"/>
    <id>http://xiaolong.li/2019/12/05/Developer-Guide-for-Golang/</id>
    <published>2019-12-05T14:24:00.000Z</published>
    <updated>2021-08-07T16:32:49.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 本规范旨在为日常Go项目开发提供一个代码的规范指导，方便团队形成一个统一的代码风格，提高代码的可读性，规范性和统一性。本规范将从命名规范，注释规范，代码风格和 Go 语言提供的常用的工具这几个方面做一个说明。该规范参考了 go 语言官方代码的风格制定。</p> <a id="more"></a><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>命名是代码规范中很重要的一部分，统一的命名规则有利于提高的代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。</p><p>Go在命名时以字母a到Z或a到Z或下划线开头，后面跟着零或更多的字母、下划线和数字(0到9)。Go不允许在命名时中使用@、$和%等标点符号。Go是一种区分大小写的编程语言。因此，Manpower和manpower是两个不同的命名。</p><p>当命名（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）。<br>命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。</p><h4 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h4><p>保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为小写单词，不要使用下划线或者混合大小写。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>尽量采取有意义的文件名，简短，有意义，应该为小写单词，使用下划线分隔各个单词。</p><blockquote><p>my_test.go</p></blockquote><h4 id="结构体命名"><a href="#结构体命名" class="headerlink" title="结构体命名"></a>结构体命名</h4><p>采用驼峰命名法，首字母根据访问控制大写或者小写。</p><p>struct 申明和初始化格式采用多行，例如下面：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多行申明</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="keyword">string</span></span><br><span class="line">    Email     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 多行初始化</span></span><br><span class="line">u := User&#123;</span><br><span class="line">    Username: <span class="string">"avatar"</span>,</span><br><span class="line">    Email:    <span class="string">"avatar@gmail.com"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h4><p>命名规则基本和上面的结构体类型。</p><p>单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><ul><li>和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则： </li><li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient</li><li>其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID</li><li>错误示例：UrlArray，应该写成 urlArray 或者 URLArray</li><li>若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isExist <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> hasConflict <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> canManage <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> allowGitHook <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><h4 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h4><p>常量均需使用全部大写字母组成，并使用下划线分词。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> APP_VER = <span class="string">"1.0"</span></span><br></pre></td></tr></table></figure><p>如果是枚举类型的常量，需要先创建相应类型：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="keyword">string</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    HTTP  Scheme = <span class="string">"http"</span></span><br><span class="line">    HTTPS Scheme = <span class="string">"https"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>下面的列表显示了Go中的保留字。这些保留字不能用作常量或变量或任何其他标识符名称。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Go 提供 C 风格的块注释和 C++ 风格的行注释。行注释是常态；块注释主要显示为包注释，但在表达式中很有用或禁用大量代码。</p><ul><li>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释</li><li>多行注释也叫块注释，均已以 /<em> 开头，并以 </em>/ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是多行注释 </span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure><p>go 语言自带的 godoc 工具可以根据注释生成文档，生成可以自动生成对应的网站（ <a href="http://golang.org" target="_blank" rel="noopener">http://golang.org</a> 就是使用 godoc 工具直接生成的），注释的质量决定了生成的文档的质量。每个包都应该有一个包注释，在package子句之前有一个块注释。对于多文件包，包注释只需要存在于一个文件中，任何一个都可以。包评论应该介绍包，并提供与整个包相关的信息。它将首先出现在godoc页面上，并应设置下面的详细文档。</p><p>详细的如何写注释可以 参考：<a href="http://golang.org/doc/effective_go.html#commentary" target="_blank" rel="noopener">http://golang.org/doc/effective_go.html#commentary</a></p><h4 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a>包注释</h4><p>每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中（一般是和包同名的文件）即可。 包注释应该包含下面基本信息(请严格按照这个顺序，简介，创建人，创建时间）：</p><ul><li>包的基本简介（包名，简介）</li><li>创建者，格式： 创建人： rtx 名</li><li>创建时间，格式：创建时间： yyyyMMdd</li></ul><p>例如 util 包的注释示例如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。</span></span><br><span class="line"><span class="comment">// 创建人： xlli5</span></span><br><span class="line"><span class="comment">// 创建时间： 20190522</span></span><br></pre></td></tr></table></figure><h4 id="结构（接口）注释"><a href="#结构（接口）注释" class="headerlink" title="结构（接口）注释"></a>结构（接口）注释</h4><p>每个自定义的结构体或者接口都应该有注释说明，该注释对结构进行简要介绍，放在结构体定义的前一行，格式为： 结构体名， 结构体说明。同时结构体内的每个成员变量都要有说明，该说明放在成员变量的后面（注意对齐），实例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User ， 用户对象，定义了用户的基础信息</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="keyword">string</span> <span class="comment">// 用户名</span></span><br><span class="line">    Email     <span class="keyword">string</span> <span class="comment">// 邮箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数（方法）注释"><a href="#函数（方法）注释" class="headerlink" title="函数（方法）注释"></a>函数（方法）注释</h4><p>每个函数，或者方法（结构体或者接口下的函数称为方法）都应该有注释说明，函数的注释应该包括三个方面（严格按照此顺序撰写）：</p><ul><li>简要说明，格式说明：以函数名开头，“，”分隔说明部分</li><li>参数列表：每行一个参数，参数名开头，“，”分隔说明部分</li><li>返回值： 每行一个返回值</li></ul><p>示例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewtAttrModel ， 属性数据层操作类的工厂方法</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      ctx ： 上下文信息</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      属性操作类指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAttrModel</span><span class="params">(ctx *common.Context)</span> *<span class="title">AttrModel</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码逻辑注释"><a href="#代码逻辑注释" class="headerlink" title="代码逻辑注释"></a>代码逻辑注释</h4><p>对于一些关键位置的代码逻辑，或者局部较为复杂的逻辑，需要有相应的逻辑说明，方便其他开发者阅读该段代码，实例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br><span class="line">xxxxx</span><br><span class="line">xxxxxxx</span><br><span class="line">xxxxxxx</span><br></pre></td></tr></table></figure><h4 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h4><p>统一使用中文注释，对于中英文字符之间严格使用空格分隔， 这个不仅仅是中文和英文之间，英文和中文标点之间也都要使用空格分隔，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br></pre></td></tr></table></figure><p>上面 Redis 、 id 、 DB 和其他中文字符之间都是用了空格分隔。</p><pre><code>建议全部使用单行注释和代码的规范一样，单行注释不要过长，禁止超过 120 字符</code></pre><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><h4 id="缩进和折行"><a href="#缩进和折行" class="headerlink" title="缩进和折行"></a>缩进和折行</h4><ul><li>缩进直接使用 gofmt 工具格式化即可（gofmt 是使用 tab 缩进的）</li><li>折行方面，一行最长不超过120个字符，超过的请使用换行展示，尽量保持格式优雅</li></ul><p>我们使用Goland开发工具，可以直接使用快捷键：ctrl+alt+L，即可。</p><h4 id="语句的结尾"><a href="#语句的结尾" class="headerlink" title="语句的结尾"></a>语句的结尾</h4><p>Go语言中是不需要类似于Java需要冒号结尾，默认一行就是一条数据</p><p>如果你打算将多个语句写在同一行，它们则必须使用。</p><h4 id="括号和空格"><a href="#括号和空格" class="headerlink" title="括号和空格"></a>括号和空格</h4><p>括号和空格方面，也可以直接使用 gofmt 工具格式化（go 会强制左大括号不换行，换行会报语法错误），所有的运算符和操作数之间要留空格。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的方式</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line">​</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 错误的方式</span></span><br><span class="line"><span class="keyword">if</span> a&gt;<span class="number">0</span>  <span class="comment">// a ，0 和 &gt; 之间应该空格</span></span><br><span class="line">&#123;       <span class="comment">// 左大括号不可以换行，会报语法错误</span></span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="import-规范"><a href="#import-规范" class="headerlink" title="import 规范"></a>import 规范</h4><p>import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">​</span><br><span class="line">    <span class="string">"myproject/models"</span></span><br><span class="line">    <span class="string">"myproject/controller"</span></span><br><span class="line">    <span class="string">"myproject/utils"</span></span><br><span class="line">​</span><br><span class="line">    <span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">    <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。</p><p>在项目中不要使用相对路径引入包：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是不好的导入</span></span><br><span class="line"><span class="keyword">import</span> “../net”</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 这是正确的做法</span></span><br><span class="line"><span class="keyword">import</span> “github.com/repo/proj/src/net”</span><br></pre></td></tr></table></figure><p>但是如果是引入本项目中的其他包，最好使用相对路径。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ul><li>错误处理的原则就是不能丢弃任何有返回err的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回err，或者使用log记录下来</li><li>尽早return：一旦有错误发生，马上返回</li><li>尽量不要使用panic，除非你知道你在做什么</li><li>错误描述如果是英文必须为小写，不需要标点结尾</li><li>采用独立的错误流进行处理</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>单元测试文件名命名规范为 example_test.go 测试用例的函数名称必须以 Test 开头，例如：TestExample 每个重要的函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p>上面提到了很过规范， go 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范，</p><p>gofmt 大部分的格式问题可以通过gofmt解决， gofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。</p><p>goimport 我们强烈建议使用 goimport ，该工具在 gofmt 的基础上增加了自动删除和引入包。</p><blockquote><p>go get golang.org/x/tools/cmd/goimports</p></blockquote><p>go vet vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。</p><blockquote><p>go get golang.org/x/tools/cmd/vet</p></blockquote><p>使用如下：</p><blockquote><p>go vet .</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本规范旨在为日常Go项目开发提供一个代码的规范指导，方便团队形成一个统一的代码风格，提高代码的可读性，规范性和统一性。本规范将从命名规范，注释规范，代码风格和 Go 语言提供的常用的工具这几个方面做一个说明。该规范参考了 go 语言官方代码的风格制定。&lt;/p&gt;
    
    </summary>
    
      <category term="GO" scheme="http://xiaolong.li/categories/GO/"/>
    
    
      <category term="编码规范" scheme="http://xiaolong.li/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="golang" scheme="http://xiaolong.li/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Java开发的设计原则-SOLID</title>
    <link href="http://xiaolong.li/2019/11/24/A-Solid-Guide-to-SOLID-Principles-in-Java/"/>
    <id>http://xiaolong.li/2019/11/24/A-Solid-Guide-to-SOLID-Principles-in-Java/</id>
    <published>2019-11-24T14:13:37.000Z</published>
    <updated>2021-08-07T16:32:49.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要讲述 Java 开发五大设计原则。</p><h3 id="什么是-S-O-L-I-D-原则"><a href="#什么是-S-O-L-I-D-原则" class="headerlink" title="什么是 S.O.L.I.D 原则"></a>什么是 S.O.L.I.D 原则</h3><p>众所周知，Java 编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计，S.O.L.I.D 是面向对象设计和编程 ( OOD &amp; OOP ) 中几个重要编码原则(Programming Priciple)的首字母缩写。</p><blockquote><p>S: Single responsibility principle [单一职责原则]<br>O: Open-closed principle [开闭原则]<br>L: Liskov substitution principle [里氏替换原则]<br>I: Interface segregation principle [接口隔离原则]<br>D: Dependency inversion principle [依赖倒置原则]</p></blockquote><a id="more"></a><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 [ SRP ]"></a>单一职责原则 [ SRP ]</h3><blockquote><p>There should never be more than one reason for a class to change.</p></blockquote><p>引起一个类发生改变的原因有且只有一个。也就是说一个类只做一件事情或者一类事情，每个类的分工是明确的，只负责一个功能。如果出现一个类有多个负责功能，那么就应该考虑将这个类拆分成多个来实现。因为如果把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能影响到另一个功能。</p><p>应用：当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！</p><h3 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 [ OCP ]"></a>开闭原则 [ OCP ]</h3><blockquote><p>Software entities like classes, modules and functions should be open for extension but closed for modifications.</p></blockquote><p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。</p><p>(1)通过增加代码来扩展功能，而不是修改已经存在的代码。<br>(2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。<br>(3)OCP支持替换的服务，而不用修改客户模块。</p><p>简言之，对扩展开放，对修改封闭。换句话说，可以去扩展类，但不要去修改类。</p><p>应用：当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。</p><h3 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则 [ LSP ]"></a>里氏替换原则 [ LSP ]</h3><blockquote><p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p></blockquote><p>父类能够替换子类，但子类不一定能替换父类。也就是说，在代码中凡是父类出现的地方，都可以用子类进行替换，并且程序不会报错，也不会在运行时出现任何异常，但反过来却不一定成立。</p><p>应用：在继承类时，务必重写（Override）父类中所有的方法，尤其需要注意父类的 protected 方法（它们往往是让您重写的），子类尽量不要暴露自己的 public 方法供外界调用。</p><p>该原则由麻省理工学院的 Barbara Liskov 女士提出，她是美国第一位获取计算机博士学位的女性，曾经也获得过计算机图灵奖。</p><h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 [ ISP ]"></a>接口隔离原则 [ ISP ]</h3><blockquote><p>The dependency of one class to another one should depend on the smallest possible interface.</p></blockquote><p>不要对外暴露没有实际意义的接口。也就是说，接口是给别人调用的，那就不要去为难别人了，尽可能保证接口的实用性吧。她好，我也好。</p><p>应用：当需要对外暴露接口时，需要再三斟酌，如果真的没有必要对外提供的，就删了吧。一旦您提供了，就意味着，您将来要多做一件事情，何苦要给自己找事做呢。</p><h3 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 [ DIP ]"></a>依赖倒置原则 [ DIP ]</h3><blockquote><p>High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.</p></blockquote><p>应该面向接口编程，不应该面向实现类编程。面向实现类编程，相当于就是论事，那是正向依赖（正常人思维）；面向接口编程，相当于通过事物表象来看本质，那是反向依赖，即依赖倒置（程序员思维）。</p><p>应用：并不是说，所有的类都要有一个对应的接口，而是说，如果有接口，那就尽量使用接口来编程吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲述 Java 开发五大设计原则。&lt;/p&gt;
&lt;h3 id=&quot;什么是-S-O-L-I-D-原则&quot;&gt;&lt;a href=&quot;#什么是-S-O-L-I-D-原则&quot; class=&quot;headerlink&quot; title=&quot;什么是 S.O.L.I.D 原则&quot;&gt;&lt;/a&gt;什么是 S.O.L.I.D 原则&lt;/h3&gt;&lt;p&gt;众所周知，Java 编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计，S.O.L.I.D 是面向对象设计和编程 ( OOD &amp;amp; OOP ) 中几个重要编码原则(Programming Priciple)的首字母缩写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;S: Single responsibility principle [单一职责原则]&lt;br&gt;O: Open-closed principle [开闭原则]&lt;br&gt;L: Liskov substitution principle [里氏替换原则]&lt;br&gt;I: Interface segregation principle [接口隔离原则]&lt;br&gt;D: Dependency inversion principle [依赖倒置原则]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://xiaolong.li/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="SOLID" scheme="http://xiaolong.li/tags/SOLID/"/>
    
      <category term="开闭原则" scheme="http://xiaolong.li/tags/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>ARTS-week-004 Have a nice day</title>
    <link href="http://xiaolong.li/2019/11/09/ARTS-week-004/"/>
    <id>http://xiaolong.li/2019/11/09/ARTS-week-004/</id>
    <published>2019-11-09T03:29:17.000Z</published>
    <updated>2021-08-07T16:32:49.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><blockquote><p>算法题</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请你来实现一个 atoi 函数，使其能将字符串转换成整数。</span><br></pre></td></tr></table></figure><a id="more"></a><p>解题思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.replaceAll(<span class="string">" "</span>, <span class="string">""</span>).equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] data = str.toCharArray();</span><br><span class="line">    <span class="keyword">boolean</span> isPositive = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; data.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!start &amp;&amp; data[index] == <span class="string">' '</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!start &amp;&amp; data[index] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            isPositive = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!start &amp;&amp; data[index] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            isPositive = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[index] &gt;= <span class="string">'0'</span> &amp;&amp; data[index] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = data[index] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (isPositive &amp;&amp; (result &gt; Integer.MAX_VALUE / <span class="number">10</span> || ( result == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; val &gt; Integer.MAX_VALUE % <span class="number">10</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isPositive &amp;&amp; ((<span class="number">0</span> - result) &lt; Integer.MIN_VALUE / <span class="number">10</span> || ((<span class="number">0</span> - result) == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; (<span class="number">0</span> - val) &lt; Integer.MIN_VALUE % <span class="number">10</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start = <span class="keyword">true</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isPositive) &#123;</span><br><span class="line">        result = <span class="number">0</span> - result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p>最近好像干了不少不过脑子的事，之前一直在 AWS 上搭梯子，昨天手一抖把 EC2 实例给销毁了，导致了没办法翻墙。然后又在 AWS 搭了一个梯子，顺便薅了点羊毛，把搭梯子的过程记录下来，以便后面再用，也分享给有用的人。</p><blockquote><p><a href="https://xiaolong.li/2019/11/03/AWS-shadowsocks-guide">亚马逊 AWS 搭建 shadowsocks 科学上网</a></p></blockquote><h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><p>最近搞了一些关于GC的事情，结合JDK8把JVM的内存结构重新整理了一下输出。后面会继续输出关于GC和OOM的一下文章。</p><blockquote><p><a href="https://xiaolong.li/2019/10/23/Introduction-to-Garbage-Collection/">JVM内存结构概述</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;算法题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="ARTS" scheme="http://xiaolong.li/categories/ARTS/"/>
    
    
  </entry>
  
</feed>
