<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NO WAY OUT | 无往不前</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiaolong.li/"/>
  <updated>2021-08-22T17:31:23.522Z</updated>
  <id>http://xiaolong.li/</id>
  
  <author>
    <name>xiaolong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP 的粘包拆包以及解决方案</title>
    <link href="http://xiaolong.li/2021/08/23/TCP-stick-package-unpacking/"/>
    <id>http://xiaolong.li/2021/08/23/TCP-stick-package-unpacking/</id>
    <published>2021-08-22T16:01:48.000Z</published>
    <updated>2021-08-22T17:31:23.522Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的。</p><p>TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为一个完整的包可能会被 TCP 拆分为多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是 TCP <strong>粘包</strong> 和 <strong>拆包</strong>。</p><a id="more"></a><h4 id="为什么-UDP没有粘包？"><a href="#为什么-UDP没有粘包？" class="headerlink" title="为什么 UDP没有粘包？"></a>为什么 UDP没有粘包？</h4><p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于 UDP 有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在 TCP 协议中。</p><h4 id="粘包拆包发生场景"><a href="#粘包拆包发生场景" class="headerlink" title="粘包拆包发生场景"></a>粘包拆包发生场景</h4><p>因为 TCP 是面向流，没有边界，而操作系统在发送 TCP 数据时，会通过缓冲区来进行优化，例如缓冲区为 1024 个字节大小。</p><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP 则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。</p><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP 就会将其拆分为多次发送，这就是拆包。</p><p>关于粘包和拆包可以参考下图的几种情况：</p><h5 id="正常数据包"><a href="#正常数据包" class="headerlink" title="正常数据包"></a>正常数据包</h5><blockquote><p>正常的理想情况，两个包恰好满足 TCP 缓冲区的大小或达到 TCP 等待时长，分别发送两个包</p></blockquote><p>服务端一共读到两个数据包，第一个包包含客户端发出的第一条消息的完整信息，第二个包包含客户端发出的第二条消息，那这种情况比较好处理，服务器只需要简单的从网络缓冲区去读就好了，第一次读到第一条消息的完整信息，消费完再从网络缓冲区将第二条完整消息读出来消费。这种情况没有发生粘包、拆包。</p><p><img src="/images/network/2021-08-23-tcp-packet-normal.png" alt="image"></p><h5 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h5><blockquote><p>两个包较小，间隔时间短，发生粘包，合并成一个包发送</p></blockquote><p>服务端一共就读到一个数据包，这个数据包包含客户端发出的两条消息的完整信息，这个时候服务端不知道如何区分原始的两个包，这种情况其实是发生了 TCP 粘包。</p><p><img src="/images/network/2021-08-23-tcp-packet-stick.png" alt="image"></p><h5 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h5><blockquote><p>一个包过大，超过缓存区大小，拆分成两个或多个包发送</p></blockquote><p><img src="/images/network/2021-08-23-tcp-packet-unpacking.png" alt="image"></p><h5 id="既有粘包又有拆包"><a href="#既有粘包又有拆包" class="headerlink" title="既有粘包又有拆包"></a>既有粘包又有拆包</h5><blockquote><p>packet_1 过大，进行了拆包处理，而拆出去的一部分又与 packet_2 进行粘包处理。</p></blockquote><p>服务端一共收到了两个数据包，第一个数据包只包含了第一条消息的一部分，第一条消息的后半部分和第二条消息都在第二个数据包中，或者是第一个数据包包含了第一条消息的完整信息和第二条消息的一部分信息，第二个数据包包含了第二条消息的剩下部分，这种情况其实是发送了 TCP 拆包，因为发生了一条消息被拆分在两个包里面发送了，同样上面的服务器逻辑对于这种情况是不好处理的。</p><p><img src="/images/network/2021-08-23-tcp-packet-stick-unpacking.png" alt="image"></p><h4 id="产生-TCP-粘包和拆包的原因"><a href="#产生-TCP-粘包和拆包的原因" class="headerlink" title="产生 TCP 粘包和拆包的原因"></a>产生 TCP 粘包和拆包的原因</h4><p>TCP 是以流的方式传输数据，传输的最小单位为一个报文段（segment）。TCP Header中有个 Options 标识位，常见的标识为 mss(Maximum Segment Size) 指的是，连接层每次传输的数据有个最大限制 MTU(Maximum Transmission Unit)，一般是 1500 比特，超过这个量要分成多个报文段，mss 则是这个最大限制减去 TCP 的 header，光是要传输的数据的大小，一般为 1460 比特。换算成字节，也就是 180 多字节。</p><p>TCP 为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了之后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制，来接收数据。</p><p>发生 TCP 粘包、拆包主要是由于下面一些原因：</p><ol><li>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</li><li>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</li><li>进行 mss（最大报文长度）大小的 TCP 分段，当 TCP 报文长度 - TCP 头部长度 &gt; mss 的时候将发生拆包。</li><li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li></ol><h4 id="如何解决拆包粘包"><a href="#如何解决拆包粘包" class="headerlink" title="如何解决拆包粘包"></a>如何解决拆包粘包</h4><p>既然TCP 是无界的数据流，且协议本身无法避免粘包，拆包的发生，那么只能在应用层数据协议上加以控制。通常在制定传输数据时，可以使用如下方法：</p><ol><li>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。</li><li>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息。</li><li>设置消息边界，服务端从网络流中按消息编辑分离出消息内容。</li></ol><p>a)先基于第三种方法，假设区分数据边界的标识为换行符 “\n”（注意请求数据本身内部不能包含换行符），数据格式为 Json，例如下面是一个符合这个规则的请求包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;message&quot;,&quot;content&quot;:&quot;hello&quot;&#125;\n</span><br></pre></td></tr></table></figure><p>注意上面的请求数据末尾有一个换行字符，代表一个请求的结束。</p><p>b)基于第一种方法，可以制定，首部固定 10 个字节长度用来保存整个数据包长度，位数不够则补 0 的数据协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000036&#123;&quot;type&quot;:&quot;message&quot;,&quot;content&quot;:&quot;hello&quot;&#125;</span><br></pre></td></tr></table></figure><p>c)基于第一种方法，可以制定，首部 4 字节网络字节序 unsigned int，标记整个包的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">****&#123;&quot;type&quot;:&quot;message&quot;,&quot;content&quot;:&quot;hello all&quot;&#125;</span><br></pre></td></tr></table></figure><p>其中首部四字节 * 号代表一个网络字节序的 unsigned int 数据，为不可见字符，紧接着是 Json 的数据格式的包体数据。</p><h4 id="Netty对粘包和拆包问题的处理"><a href="#Netty对粘包和拆包问题的处理" class="headerlink" title="Netty对粘包和拆包问题的处理"></a>Netty对粘包和拆包问题的处理</h4><p>Netty 对解决粘包和拆包的方案做了抽象，提供了一些解码器（Decoder）来解决粘包和拆包的问题。如：</p><ul><li>LineBasedFrameDecoder：以行为单位进行数据包的解码；</li><li>DelimiterBasedFrameDecoder：以特殊的符号作为分隔来进行数据包的解码；</li><li>FixedLengthFrameDecoder：以固定长度进行数据包的解码；</li><li>LenghtFieldBasedFrameDecode：适用于消息头包含消息长度的协议（最常用）；</li></ul><p>基于 Netty 进行网络读写的程序，可以直接使用这些 Decoder 来完成数据包的解码。对于高并发、大流量的系统来说，每个数据包都不应该传输多余的数据（所以补齐的方式不可取），LenghtFieldBasedFrameDecode 更适合这样的场景。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>TCP 协议粘包拆包问题是因为 TCP 协议数据传输是基于字节流的，它不包含消息、数据包等概念，需要应用层协议自己设计消息的边界，即消息帧（Message Framing）。如果应用层协议没有使用基于长度、终结符信息或者消息边界等方式进行处理，则会导致多个消息的粘包和拆包。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的。&lt;/p&gt;
&lt;p&gt;TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为一个完整的包可能会被 TCP 拆分为多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是 TCP &lt;strong&gt;粘包&lt;/strong&gt; 和 &lt;strong&gt;拆包&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://xiaolong.li/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://xiaolong.li/tags/TCP/"/>
    
      <category term="粘包" scheme="http://xiaolong.li/tags/%E7%B2%98%E5%8C%85/"/>
    
      <category term="拆包" scheme="http://xiaolong.li/tags/%E6%8B%86%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>一文彻底搞懂 TCP 三次握手、四次挥手过程及原理</title>
    <link href="http://xiaolong.li/2021/08/20/Introduction-to-TCP/"/>
    <id>http://xiaolong.li/2021/08/20/Introduction-to-TCP/</id>
    <published>2021-08-20T03:23:39.000Z</published>
    <updated>2021-08-21T15:56:30.797Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="TCP-协议简述"><a href="#TCP-协议简述" class="headerlink" title="TCP 协议简述"></a>TCP 协议简述</h4><p>TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。<br>无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，连接是通过 <strong>三次握手</strong> 进行初始化的。<br>同时由于 TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP 是 <strong>全双工模式</strong>，所以需要 <strong>四次挥手</strong> 关闭连接。</p><a id="more"></a><h4 id="TCP-包首部"><a href="#TCP-包首部" class="headerlink" title="TCP 包首部"></a>TCP 包首部</h4><p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。</p><p>所以在学习 TCP 协议之前，首先要知道 TCP 在网络传输中处于哪个位置，以及它的协议的规范，下面我们就看看 TCP 首部的网络传输起到的作用：</p><p><img src="/images/network/2021-08-20-tcp-msg.png" alt="image"></p><p>下面的图是 TCP 头部的规范定义，它定义了 TCP 协议如何读取和解析数据：</p><p><img src="/images/network/2021-08-20-tcp-header.png" alt="image"></p><p>TCP 首部承载这 TCP 协议需要的各项信息，下面我们来分析一下：</p><h5 id="TCP-端口号"><a href="#TCP-端口号" class="headerlink" title="TCP 端口号"></a>TCP 端口号</h5><p>TCP 的连接是需要四个要素确定唯一一个连接：</p><blockquote><p>（源IP，源端口号）+ （目地IP，目的端口号）</p></blockquote><p>所以 TCP 首部预留了两个 16 位作为端口号的存储，而 IP 地址由上一层 IP 协议负责传递，源端口号和目地端口各占 16 位两个字节，也就是端口的范围是 2^16=65535，另外 1024  以下是系统保留的，从 1024-65535 是用户使用的端口范围。</p><h5 id="TCP-的序号和确认号"><a href="#TCP-的序号和确认号" class="headerlink" title="TCP 的序号和确认号"></a>TCP 的序号和确认号</h5><p><strong>32位序号 seq</strong>：Sequence number 缩写 <strong>seq</strong> ，TCP 通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据有序，比如现在序列号为 1000，发送了 1000，下一个序列号就是 2000。<br><strong>32位确认号 ack</strong>：Acknowledge number 缩写 <strong>ack</strong>，TCP 对上一次 seq 序号做出的确认号，用来响应 TCP 报文段，给收到的 TCP 报文段的序号 seq 加 1。</p><h4 id="TCP-的标志位"><a href="#TCP-的标志位" class="headerlink" title="TCP 的标志位"></a>TCP 的标志位</h4><p>每个 TCP 段都有一个目的，这是借助于 TCP 标志位选项来确定的，允许发送方或接收方指定哪些标志应该被使用，以便段被另一端正确处理。<br>用的最广泛的标志是 <strong>SYN</strong>，<strong>ACK</strong> 和 <strong>FIN</strong>，用于建立连接，确认成功的段传输，最后终止连接。</p><blockquote><p><strong>SYN</strong>：简写为S，同步标志位，用于建立会话连接，同步序列号；<br><strong>ACK</strong>：简写为.，确认标志位，对已接收的数据包进行确认；<br><strong>FIN</strong>：简写为F，完成标志位，表示我已经没有数据要发送了，即将关闭连接；<br><strong>PSH</strong>：简写为P，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；<br><strong>RST</strong>：简写为R，重置标志位，用于连接复位、拒绝错误和非法的数据包；<br><strong>URG</strong>：简写为U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；</p></blockquote><h4 id="TCP-三次握手建立连接"><a href="#TCP-三次握手建立连接" class="headerlink" title="TCP 三次握手建立连接"></a>TCP 三次握手建立连接</h4><p>所谓三次握手 (Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个报文。</p><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时，将触发三次握手。</p><p>三次握手过程的示意图如下：</p><p><img src="/images/network/2021-08-20-tcp-established.png" alt="image"></p><h5 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h5><p>客户端将 TCP 报文标志位 SYN 置为 1，随机产生一个序号值 seq = J，保存在 TCP 首部的序列号 (Sequence Number) 字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入 SYN_SENT 状态，等待服务器端确认。</p><h5 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h5><p>服务器端收到数据包后由标志位 SYN = 1 知道客户端请求建立连接，服务器端将 TCP 报文标志位 SYN 和 ACK 都置为 1，ack = J + 1，随机产生一个序号值 seq = K ，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态。</p><h5 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h5><p>客户端收到确认后，检查 ack 是否为 J + 1 ，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p><blockquote class="blockquote-center"><p><strong>第三次握手允许携带数据</strong></p></blockquote><p>注意：上面写的 <strong>ack 和 ACK 不是同一个概念</strong>：</p><blockquote><p>小写的 ack 代表的是头部的确认号 Acknowledge number， 缩写 ack ，是对上一个包的序号进行确认的号，ack=seq+1。<br>大写的 ACK 是上面说的 TCP 首部的标志位，用于标志的 TCP 包是否对上一个包进行了确认操作，如果确认了，则把 ACK 标志位设置成1。</p></blockquote><p>下面我自己做实验，开一个 HTTP 服务，监听 80 端口，然后使用 Tcpdump 命令抓包，看一下 TCP 三次握手的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo tcpdump -n -t -S -i enp0s3  port 80 </span><br><span class="line"></span><br><span class="line">第一次握手，标志位Flags=S</span><br><span class="line">IP 10.0.2.2.51323 &gt; 10.0.2.15.80: Flags [S], seq 84689409, win 65535, options [mss 1460], length 0</span><br><span class="line">第二次握手，标志位Flags=[S.]</span><br><span class="line">IP 10.0.2.15.80 &gt; 10.0.2.2.51323: Flags [S.], seq 1893430205, ack 84689410, win 64240, options [mss 1460], length 0</span><br><span class="line">第三次握手，标志位Flags=[.]</span><br><span class="line">IP 10.0.2.2.51323 &gt; 10.0.2.15.80: Flags [.], ack 1893430206, win 65535, length 0</span><br><span class="line">建立连接后，客户端发送http请求 </span><br><span class="line">IP 10.0.2.2.51321 &gt; 10.0.2.15.80: Flags [P.], seq 1:753, ack 1, win 65535, length 752: HTTP: GET / HTTP/1.1</span><br></pre></td></tr></table></figure><p>tcpdump命令解析一下：</p><blockquote><p>-i: 指定抓包的网卡是enp0s3<br>-n: 把域名转成IP显示<br>-t: 不显示时间<br>-S: 序列号使用绝对数值，不指定-S的话，序列号会使用相对的数值<br>port: 指定监听端口是80<br>host: 指定监听的主机名</p></blockquote><p>实战中TCP的三次握手过程：</p><blockquote><p>第一次握手，客户端51323端口号向服务器端80号端口发起连接，此时标志位flags=S，即SYN=1标志，表示向服务端发起连接的请求，同时生成序列号seq=84689409<br>第二次握手，服务端标志位flags=[S.]，即SYN+ACK标志位设置为1，表示对上一个请求连接的报文进行确认，同时设置ack=seq+1=184689410，生成序列号seq=1893430205<br>第三次握手，客户端对服务端的响应进行确认，所以此时标志位是[.]即ACK=1，同时返回对上一个报文的seq的确认号，ack=1893430206<br>至此，三次握手完成，一个TCP连接建立完成，接下来就是双端传输数据了</p></blockquote><h5 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h5><p>假设 client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。</p><p>本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。</p><p>假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。</p><p>所以，采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p><h4 id="TCP-四次挥手关闭连接"><a href="#TCP-四次挥手关闭连接" class="headerlink" title="TCP 四次挥手关闭连接"></a>TCP 四次挥手关闭连接</h4><p>四次挥手即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。</p><p>在 socket 编程中，这一过程由客户端或服务端任一方执行 close 来触发。</p><p>由于 TCP 连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，A 发送一个 FIN 来终止连接，B 收到一个 FIN ，只是意味着 A-&gt;B 方向上没有数据流动了，即B不会再收到数据了，但是在这个 TCP 连接上 B 仍然能够发送数据，直到 B 也向 A 发送了 FIN ，才能说明需要关闭连接。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p><p>四次挥手过程的示意图如下：</p><p><img src="/images/network/2021-08-20-tcp-close.png" alt="image"></p><p>挥手请求可以是 Client 端，也可以是 Server 端发起的，我们假设是 Client 端发起：</p><h5 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h5><p>Client 端发起挥手请求，向 Server 端发送标志位是 FIN 报文段，设置序列号 seq ，此时，Client 端进入 FIN_WAIT_1 状态，这表示 Client 端没有数据要发送给 Server 端了。</p><h5 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h5><p>Server 端收到了 Client 端发送的 FIN 报文段，向 Client 端返回一个标志位是 ACK 的报文段，ack 设为 seq + 1，Client 端进入 FIN_WAIT_2 状态，Server 端告诉 Client 端，我确认并同意你的关闭请求。</p><h5 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h5><p>Server 端向 Client 端发送标志位是 FIN 的报文段，请求关闭连接，同时 Client 端进入 LAST_ACK 状态。</p><h5 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h5><p>Client 端收到 Server 端发送的 FIN 报文段，向 Server 端发送标志位是 ACK 的报文段，然后 Client 端进入 TIME_WAIT 状态。Server 端收到 Client 端的 ACK 报文段以后，就关闭连接。此时，Client 端 <strong>等待 2MSL</strong> 的时间后依然没有收到回复，则证明 Server 端已正常关闭，那好，Client 端也可以关闭连接了。</p><h5 id="为什么关闭的时候却是四次握手？"><a href="#为什么关闭的时候却是四次握手？" class="headerlink" title="为什么关闭的时候却是四次握手？"></a>为什么关闭的时候却是四次握手？</h5><p>建立连接时因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN + ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的，所以建立连接只需要三次握手。</p><p>由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式。这就意味着，关闭连接时，当 Client 端发出 FIN 报文段时，只是表示 Client 端告诉 Server 端数据已经发送完毕了。当 Server 端收到 FIN 报文并返回 ACK 报文段，表示它已经知道 Client 端没有数据发送了，但是 Server 端还是可以发送数据到 Client 端的，所以 Server 很可能并不会立即关闭 SOCKET ，直到 Server 端把数据也发送完毕。当 Server 端也发送了 FIN 报文段时，这个时候就表示 Server 端也没有数据要发送了，就会告诉 Client 端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h5 id="为什么要等待-2MSL-？"><a href="#为什么要等待-2MSL-？" class="headerlink" title="为什么要等待 2MSL ？"></a>为什么要等待 2MSL ？</h5><p><strong>MSL</strong>：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p><p>有以下两个原因：</p><p>第一点：保证 TCP 协议的全双工连接能够可靠关闭。由于 IP 协议的不可靠性或者是其它网络原因，导致了 Server 端没有收到 Client 端的 ACK 报文，那么 Server 端就会在超时之后重新发送 FIN ，如果此时 Client 端的连接已经关闭处于 CLOESD 状态，那么重发的 FIN 就找不到对应的连接了，从而导致连接错乱，所以，Client 端发送完最后的 ACK 不能直接进入 CLOSED 状态，而要保持 TIME_WAIT ，当再次收到 FIN 的收，能够保证对方收到 ACK ，最后正确关闭连接。</p><p>第二点：保证这次连接的重复数据段从网络中消失。如果 Client 端发送最后的 ACK 直接进入 CLOSED 状态，然后又再向 Server 端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TCP-协议简述&quot;&gt;&lt;a href=&quot;#TCP-协议简述&quot; class=&quot;headerlink&quot; title=&quot;TCP 协议简述&quot;&gt;&lt;/a&gt;TCP 协议简述&lt;/h4&gt;&lt;p&gt;TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。&lt;br&gt;无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，连接是通过 &lt;strong&gt;三次握手&lt;/strong&gt; 进行初始化的。&lt;br&gt;同时由于 TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP 是 &lt;strong&gt;全双工模式&lt;/strong&gt;，所以需要 &lt;strong&gt;四次挥手&lt;/strong&gt; 关闭连接。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://xiaolong.li/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://xiaolong.li/tags/TCP/"/>
    
      <category term="三次握手" scheme="http://xiaolong.li/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    
      <category term="四次挥手" scheme="http://xiaolong.li/tags/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis 持久化机制</title>
    <link href="http://xiaolong.li/2021/08/15/Redis-Persistence/"/>
    <id>http://xiaolong.li/2021/08/15/Redis-Persistence/</id>
    <published>2021-08-15T15:15:23.000Z</published>
    <updated>2021-08-15T16:21:59.296Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis 是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好 Redis 还为我们提供了持久化的机制，分别是 RDB(Redis DataBase) 和 AOF(Append Only File)。</p><h4 id="持久化流程"><a href="#持久化流程" class="headerlink" title="持久化流程"></a>持久化流程</h4><p>Redis 的数据持久化就是可以将数据保存在磁盘上，主要有下面五个过程：</p><blockquote><p>（1）客户端向服务端发送写操作(数据在客户端的内存中)。</p><p>（2）数据库服务端接收到写请求的数据(数据在服务端的内存中)。</p><p>（3）服务端调用 write 这个系统调用，将数据往磁盘上写(数据在系统内存的缓冲区中)。</p><p>（4）操作系统将缓冲区中的数据转移到磁盘控制器上(数据在磁盘缓存中)。</p><p>（5）磁盘控制器将数据写到磁盘的物理介质中(数据真正落到磁盘上)。</p></blockquote><a id="more"></a><p>这 5 个过程是在理想条件下一个正常的保存流程，但是在大多数情况下，我们的机器等等都会有各种各样的故障，这里划分了两种情况：</p><blockquote><p>（1）Redis 数据库发生故障，只要在上面的第三步执行完毕，那么就可以持久化保存，剩下的两步由操作系统替我们完成。</p><p>（2）操作系统发生故障，必须上面 5 步都完成才可以。</p></blockquote><p>在这里只考虑了保存的过程可能发生的故障，其实保存的数据也有可能发生损坏，需要一定的恢复机制，不过在这里就不再延伸了。现在主要考虑的是 Redis 如何来实现上面 5 个保存磁盘的步骤。它提供了两种策略机制，也就是 RDB 和 AOF。</p><h4 id="RDB-机制"><a href="#RDB-机制" class="headerlink" title="RDB 机制"></a>RDB 机制</h4><p>RDB 其实就是把数据以快照的形式保存在磁盘上。什么是快照呢? 你可以理解成把当前时刻的数据拍成一张照片保存下来。</p><p>RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为 dump.rdb。</p><blockquote class="blockquote-center"><p>在安装了 Redis 之后，所有的配置都是在 redis.conf 文件中，里面保存了 RDB 和 AOF 两种持久化机制的各种配置</p></blockquote><p>既然 RDB 机制是通过把某个时刻的所有数据生成一个快照来保存，那么就应该有一种触发机制，是实现这个过程。对于 RDB 来说，提供了三种机制：save、bgsave、自动化。</p><h5 id="save-触发方式"><a href="#save-触发方式" class="headerlink" title="save 触发方式"></a>save 触发方式</h5><p>该命令会阻塞当前 Redis 服务器，执行 save 命令期间，Redis 不能处理其他命令，直到 RDB 过程完成为止。具体流程如下：</p><p><img src="/images/redis/2021-08-15-save-cmd.jpeg" alt="image" title="save命令"></p><p>执行完成时候如果存在老的 RDB 文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p><h5 id="bgsave-触发方式"><a href="#bgsave-触发方式" class="headerlink" title="bgsave 触发方式"></a>bgsave 触发方式</h5><p>执行该命令时，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p><p><img src="/images/redis/2021-08-15-bgsave-cmd.jpeg" alt="image" title="bgsave命令"></p><p>具体操作是 Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。基本上 Redis 内部所有的 RDB 操作都是采用 bgsave 命令。</p><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>自动触发是由配置文件来完成的。在 redis.conf 配置文件中，有如下配置可以设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1、save：这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</span><br><span class="line">默认如下配置：</span><br><span class="line"></span><br><span class="line">&apos;#&apos;  表示900 秒内如果至少有1个key的值发生变化，则保存save 900 </span><br><span class="line">&apos;1#&apos;  表示300 秒内如果至少有10个key的值变化，则保存save 300 </span><br><span class="line">&apos;10#&apos; 表示60 秒内如果至少有10000个key的值变化，则保存save 60 10000</span><br><span class="line"></span><br><span class="line">不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 2、&apos;stop-writes-on-bgsave-error&apos;：默认值为yes。当启用了RDB且最后一次后台保存数据失败时，Redis是否停止接收数据，这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</span><br><span class="line">&gt;</span><br><span class="line">&gt; 3、&apos;rdbcompression&apos;：默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 4、&apos;rdbchecksum&apos;：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 5、&apos;dbfilename&apos;：设置快照的文件名，默认是 dump.rdb</span><br><span class="line">&gt;</span><br><span class="line">&gt; 6、&apos;dir&apos;：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</span><br></pre></td></tr></table></figure><p>可以修改这些配置来实现我们想要的效果。因为第三种方式是配置的，所以对前两种进行一个对比：</p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO 类型</td><td>同步</td><td>异步</td></tr><tr><td>是否阻塞</td><td>是</td><td>是（阻塞发生在 fork 时）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要 fork ，消耗内存</td></tr></tbody></table><h4 id="RDB-的优势和劣势"><a href="#RDB-的优势和劣势" class="headerlink" title="RDB 的优势和劣势"></a>RDB 的优势和劣势</h4><p><strong>优势</strong> ：</p><blockquote><p>（1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p><p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p><p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p></blockquote><p><strong>劣势</strong>：</p><p>RDB 快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p><h4 id="AOF-机制"><a href="#AOF-机制" class="headerlink" title="AOF 机制"></a>AOF 机制</h4><p>全量备份总是耗时的，提供一种更加高效的方式 AOF，工作机制很简单，Redis 会将每一个收到的写命令都通过 write 函数追加到文件中。通俗的理解就是日志记录。</p><h5 id="持久化原理"><a href="#持久化原理" class="headerlink" title="持久化原理"></a>持久化原理</h5><p><img src="/images/redis/2021-08-15-aof-persistence.jpeg" alt="image" title="AOF 运行原理"></p><p>每当有一个写命令过来时，就直接保存在我们的 AOF 文件中。</p><h5 id="文件重写原理"><a href="#文件重写原理" class="headerlink" title="文件重写原理"></a>文件重写原理</h5><p>AOF 的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩 aof 的持久化文件。Redis提供了 bgrewriteaof 命令。将内存中的数据以命令的方式保存到临时文件中，同时会 fork 出一条新进程来将文件重写。</p><p><img src="/images/redis/2021-08-15-aof-rewrite-file.jpeg" alt="image" title="AOF文件重写原理"></p><p>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似。</p><h5 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h5><p>AOF 也有三种触发机制，always、everysec、和 no。</p><blockquote><p>（1）每修改同步 always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p><p>（2）每秒同步 everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</p><p>（3）不同 no：从不同步</p></blockquote><p>三种触发机制对比：</p><table><thead><tr><th>命令</th><th>always</th><th>everysec</th><th>no</th></tr></thead><tbody><tr><td>优点</td><td>不丢失数据</td><td>每秒一次 fsync <br> 最大丢一秒数据</td><td>不用运维</td></tr><tr><td>缺点</td><td>IO 开销较大<br>一般的 SATA 盘只有几百 TPS</td><td>丢一秒数据</td><td>不可控</td></tr></tbody></table><h5 id="AOF-的优势和劣势"><a href="#AOF-的优势和劣势" class="headerlink" title="AOF 的优势和劣势"></a>AOF 的优势和劣势</h5><p><strong>优势</strong>：</p><blockquote><p>（1）AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒通过一个后台线程执行一次 fsync 操作，最多丢失 1 秒钟的数据。</p><p>（2）AOF 日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p><p>（3）AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p><p>（4）AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。</p></blockquote><p><strong>劣势</strong>：</p><blockquote><p>（1）对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</p><p>（2）AOF 开启后，支持的写 QPS 会比 RDB 支持的低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的</p><p>（3）AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</p></blockquote><h4 id="RDB和AOF到底该如何选择"><a href="#RDB和AOF到底该如何选择" class="headerlink" title="RDB和AOF到底该如何选择"></a>RDB和AOF到底该如何选择</h4><p>一般根据需求不同选择的也不通，但是通常都是结合使用。总结：</p><table><thead><tr><th>命令</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>宕机容易丢数据</td><td>根据策略决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好 Redis 还为我们提供了持久化的机制，分别是 RDB(Redis DataBase) 和 AOF(Append Only File)。&lt;/p&gt;
&lt;h4 id=&quot;持久化流程&quot;&gt;&lt;a href=&quot;#持久化流程&quot; class=&quot;headerlink&quot; title=&quot;持久化流程&quot;&gt;&lt;/a&gt;持久化流程&lt;/h4&gt;&lt;p&gt;Redis 的数据持久化就是可以将数据保存在磁盘上，主要有下面五个过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）客户端向服务端发送写操作(数据在客户端的内存中)。&lt;/p&gt;
&lt;p&gt;（2）数据库服务端接收到写请求的数据(数据在服务端的内存中)。&lt;/p&gt;
&lt;p&gt;（3）服务端调用 write 这个系统调用，将数据往磁盘上写(数据在系统内存的缓冲区中)。&lt;/p&gt;
&lt;p&gt;（4）操作系统将缓冲区中的数据转移到磁盘控制器上(数据在磁盘缓存中)。&lt;/p&gt;
&lt;p&gt;（5）磁盘控制器将数据写到磁盘的物理介质中(数据真正落到磁盘上)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://xiaolong.li/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://xiaolong.li/tags/redis/"/>
    
      <category term="rdb" scheme="http://xiaolong.li/tags/rdb/"/>
    
      <category term="aof" scheme="http://xiaolong.li/tags/aof/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现消息队列</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Message-queue/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Message-queue/</id>
    <published>2021-08-12T08:08:26.000Z</published>
    <updated>2021-08-12T08:09:53.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现配置中心</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Configuration/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Configuration/</id>
    <published>2021-08-12T08:07:50.000Z</published>
    <updated>2021-08-12T08:09:23.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现注册中心</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Registry/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Registry/</id>
    <published>2021-08-12T08:05:44.000Z</published>
    <updated>2021-08-12T08:10:07.691Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现分布式事务</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Distributed-transaction/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Distributed-transaction/</id>
    <published>2021-08-12T08:04:04.000Z</published>
    <updated>2021-08-12T08:09:36.933Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现分布式锁</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Distributed-lock/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Distributed-lock/</id>
    <published>2021-08-12T08:03:23.000Z</published>
    <updated>2021-08-12T08:09:21.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 实现负载均衡</title>
    <link href="http://xiaolong.li/2021/08/12/Zookeeper-for-Load-balancing/"/>
    <id>http://xiaolong.li/2021/08/12/Zookeeper-for-Load-balancing/</id>
    <published>2021-08-12T08:03:01.000Z</published>
    <updated>2021-08-12T08:09:45.165Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebRTC 中的 RTP 及 RTCP 介绍</title>
    <link href="http://xiaolong.li/2021/08/12/Introduction-RTP-RTCP-in-WebRTC/"/>
    <id>http://xiaolong.li/2021/08/12/Introduction-RTP-RTCP-in-WebRTC/</id>
    <published>2021-08-12T02:22:05.000Z</published>
    <updated>2021-08-12T07:42:04.617Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>WebRTC 技术是激烈的开放的 Web 战争中一大突破。- Brendan Eich, inventor of Java</p></blockquote><h4 id="UDP-还是-TCP？"><a href="#UDP-还是-TCP？" class="headerlink" title="UDP 还是 TCP？"></a>UDP 还是 TCP？</h4><p>如果抛开 WebRTC，让你自己实现一套实时互动直播系统，在选择网络传输协议时，你会选择使用 UDP 协议还是 TCP 协议呢？</p><p>这个问题在 2011 年至 2012 年一直是一件困扰着我们整个团队的大事儿，因为当时在国内很少有用 UDP 作为底层传输协议的。UDP 虽然传输快，但不可靠，尤其是在用户的网络质量很差的情况下，基本无法保障音视频的服务质量。</p><p>当时能想到的解决方案是，如果采用 UDP 作为底层传输协议，那就使用 RUDP（可靠性 UDP），只有这样才能保障传输过程中不丢包。但有人提出反对意见，认为如果想不丢包，就该使用 TCP，因为 RUDP 可靠性做到极致就变成 TCP 了，那为什么不直接使用 TCP 呢？</p><p>面对这种情况，2019 年的你会做何种选择呢？UDP 还是 TCP？你能拿出让人真正信服的理由吗？</p><p>现在让我告诉你正确答案：<strong>必须使用 UDP，必须使用 UDP，必须使用 UDP</strong>，重要的事情说三遍。</p><a id="more"></a><p>为什么一定要使用 UDP 呢？关于这个问题，你可以反向思考下，假如使用 TCP 会怎样呢？在极端网络情况下，TCP 为了传输的可靠性，它是如何做的呢？简单总结起来就是“发送 -&gt; 确认；超时 -&gt; 重发”的反复过程。</p><p>举个例子，A 与 B 通讯，A 首先向 B 发送数据，并启动一个定时器。当 B 收到 A 的数据后，B 需要给 A 回一个 ACK（确认）消息，反复这样操作，数据就源源不断地从 A 流向了 B。如果因为某些原因，A 一直收不到 B 的确认消息会怎么办呢？当 A 的定时器超时后，A 将重发之前没有被确认的消息，并重新设置定时器。</p><p>在 TCP 协议中，为了避免重传次数过多，定时器的超时时间会按 2 的指数增长。也就是说，假设第一次设置的超时时间是 1 秒，那么第二次就是 2 秒，第三次是 4 秒……第七次是 64 秒。如果第七次之后仍然超时，则断开 TCP 连接。你可以计算一下，从第一次超时，到最后断开连接，这之间一共经历了 2 分 07 秒，是不是很恐怖？</p><p>如果遇到前面的情况，A 与 B 之间的连接断了，那还算是个不错的情况，因为还可以再重新建立连接。但如果在第七次重传后，A 收到了 B 的 ACK 消息，那么 A 与 B 之间的数据传输的延迟就达到 1 分钟以上。对于这样的延迟，实时互动的直播系统是根本无法接受的。</p><p>基于以上的原因，在实现 <strong>实时互动直播系统的时候你必须使用 UDP 协议</strong> 。</p><h4 id="RTP-amp-RTCP"><a href="#RTP-amp-RTCP" class="headerlink" title="RTP &amp; RTCP"></a>RTP &amp; RTCP</h4><p>一般情况下，在实时互动直播系统传输音视频数据流时，我们并不直接将音视频数据流交给 UDP 传输，而是先给音视频数据加个 RTP 头，然后再交给 UDP 进行传输。为什么要这样做呢？</p><p>我们以视频帧为例，一个 I 帧的数据量是非常大的，最少也要几十 K（I/P/B 帧的概念我在前面《03 | 如何使用浏览器给自己拍照呢?》的文章中有过介绍）。而以太网的最大传输单元是多少呢？ 1.5K，所以要传输一个 I 帧需要几十个包。并且这几十个包传到对端后，还要重新组装成 I 帧，这样才能进行解码还原出一幅幅的图像。如果是我们自己实现的话，要完成这样的过程，至少需要以下几个标识。</p><blockquote><p>序号：用于标识传输包的序号，这样就可以知道这个包是第几个分片了。</p><p>起始标记：记录分帧的第一个 UDP 包。</p><p>结束标记：记录分帧的最后一个 UDP 包。</p></blockquote><p>有了上面这几个标识字段，我们就可以在发送端进行拆包，在接收端将视频帧重新再组装起来了。</p><h5 id="RTP-协议"><a href="#RTP-协议" class="headerlink" title="RTP 协议"></a>RTP 协议</h5><p>其实，这样的需求在很早之前就已经有了。因此，人们专门定义了一套规范，它就是 RTP 协议。下面让我们来详细看一下 RTP 协议吧。</p><p>如图所示，RTP 协议非常简单，我这里按字段的重要性从高往低的顺序讲解一下。</p><blockquote><p><strong>sequence number</strong>：序号，用于记录包的顺序。这与上面我们自己实现拆包、组包是同样的道理。</p><p><strong>timestamp</strong>：时间戳，同一个帧的不同分片的时间戳是相同的。这样就省去了前面所讲的 <strong>起始标记</strong> 和 <strong>结束标记</strong>。一定要记住，<strong>不同帧的时间戳肯定是不一样的</strong>。</p><p><strong>PT</strong>：Payload Type，数据的负载类型。音频流的 PT 值与视频的 PT 值是不同的，通过它就可以知道这个包存放的是什么类型的数据。</p><p>……</p></blockquote><p>这里，我并没有将 RTP 协议头中的所有字段的详细说明都列在这儿，如果你想了解所有字段的含义，可以到参考一节查看其他字段的含义。需要注意的是，这里没有将它们列出来并不代表它们不重要。恰恰相反，如果你想做音视频传输相关的工作，RTP 头中的每个字段的含义你都必须全部清楚。</p><p>知道了上面这些字段的含义后，下面我们还是来看一个具体的例子吧！假设你从网上接收到一组音视频数据，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:13,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:14,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:14,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:15,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:15,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:16,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:16,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:17,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:17,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:18,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:18,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:19,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:98,seq:19,ts:1122334455,ssrc=2345&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=0,PT:111,seq:20,ts:1122334455,ssrc=888&#125;,</span><br><span class="line">&#123;V=2,P=0,X=0,CC=0,M=1,PT:98,seq:20,ts:1122334455,ssrc=2345&#125;,</span><br></pre></td></tr></table></figure><p>假设 PT=98 是视频数据，PT=111 是音频数据，那么按照上面的规则你是不是很容易就能将视频帧组装起来呢？</p><h5 id="RTCP-协议"><a href="#RTCP-协议" class="headerlink" title="RTCP 协议"></a>RTCP 协议</h5><p>在使用 RTP 包传输数据时，难免会发生丢包、乱序、抖动等问题，下面我们来看一下使用的网络一般都会在什么情况下出现问题：</p><blockquote><p>网络线路质量问题引起丢包率高;</p><p>传输的数据超过了带宽的负载引起的丢包问题;</p><p>信号干扰（信号弱）引起的丢包问题;</p><p>跨运营商引入的丢包问题;</p><p>……</p></blockquote><p>WebRTC 对这些问题在底层都有相应的处理策略，但在处理这些问题之前，它首先要让各端都知道它们自己的网络质量到底是怎样的，这就是 RTCP 的作用。</p><p><strong>RTCP 有两个最重要的报文：RR（Reciever Report）和 SR(Sender Report)。通过这两个报文的交换，各端就知道自己的网络质量到底如何了。</strong></p><p>RTCP 支持的所有报文及其含义可以查看文章最后所附的参考一节。这里我们以 SR 报文为例，看看 SR 报文中都包括哪些信息。</p><p>下面我就简要说明一下该报文中字段的含义：</p><blockquote><p>V=2，指报文的版本。</p><p>P，表示填充位，如果该位置 1，则在 RTCP 报文的最后会有填充字节（内容是按字节对齐的）。</p><p>RC，全称 Report Count，指 RTCP 报文中接收报告的报文块个数。</p><p>PT=200，Payload Type，也就是说 SR 的值为 200。</p><p>……</p></blockquote><p>与 RTP 协议头一样，上面只介绍了 RTCP 头字段的含义，至于其他每个字段的含义请查看参考一节。同样的，对于 RTCP 头中的每个字段也必须都非常清楚，只有这样以后你在看 WebRTC 带宽评估相关的代码时，才不至于晕头转向。从上图中我们可以了解到，SR 报文分成三部分：Header、Sender info 和 Report block。在 NTP 时间戳之上的部分为 SR 报文的 Header 部分，SSRC_1 字段之上到 Header 之间的部分为 Sender info 部分，剩下的就是一个一个的 Report Block 了。那这每一部分是用于干什么的呢？</p><blockquote><p>Header 部分用于标识该报文的类型，比如是 SR 还是 RR。</p><p>Sender info 部分用于指明作为发送方，到底发了多少包。</p><p>Report block 部分指明发送方作为接收方时，它从各个 SSRC 接收包的情况。</p></blockquote><p>通过以上的分析，你可以发现 SR 报文并不仅是指发送方发了多少数据，它还报告了作为接收方，它接收到的数据的情况。当发送端收到对端的接收报告时，它就可以根据接收报告来评估它与对端之间的网络质量了，随后再根据网络质量做传输策略的调整。</p><p><strong>SR</strong> 报文与 <strong>RR</strong> 报文无疑是 RTCP 协议中最重要的两个报文，不过 RTCP 中的其他报文也都非常重要的，如果你想学好 WebRTC ，那么 RTCP 中的每个报文你都必须掌握。</p><p>比如，RTCP 类型为 206、子类型为 4 的 FIR 报文，其含义是 Full Intra Request (FIR) Command，即 <strong>完整帧请求</strong> 命令。它起什么作用？又在什么时候使用呢？</p><p>该报文也是一个特别关键的报文，我为什么这么说呢？试想一下，在一个房间里有 3 个人进行音视频聊天，然后又有一个人加入到房间里，这时如果不做任何处理的话，那么第四个人进入到房间后，在一段时间内很难直接看到其他三个人的视频画面了，这是为什么呢？</p><p>原因就在于解码器在解码时有一个上下文。在该上下文中，必须先拿到一个 IDR 帧之后才能将其后面的 P 帧、B 帧进行解码。也就是说，在没有 IDR 帧的情况下，对于收到的 P 帧、B 帧解码器只能干瞪眼了。</p><p>如何解决这个问题呢？这就引出了 FIR 报文。当第四个人加入到房间后，它首先发送 FIR 报文，当其他端收到该报文后，便立即产生各自的 IDR 帧发送给新加入的人，这样当新加入的人拿到房间中其他的 IDR 帧后，它的解码器就会解码成功，于是其他人的画面也就一下子全部展示出来了。所以你说它是不是很重要呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;WebRTC 技术是激烈的开放的 Web 战争中一大突破。- Brendan Eich, inventor of Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;UDP-还是-TCP？&quot;&gt;&lt;a href=&quot;#UDP-还是-TCP？&quot; class=&quot;headerlink&quot; title=&quot;UDP 还是 TCP？&quot;&gt;&lt;/a&gt;UDP 还是 TCP？&lt;/h4&gt;&lt;p&gt;如果抛开 WebRTC，让你自己实现一套实时互动直播系统，在选择网络传输协议时，你会选择使用 UDP 协议还是 TCP 协议呢？&lt;/p&gt;
&lt;p&gt;这个问题在 2011 年至 2012 年一直是一件困扰着我们整个团队的大事儿，因为当时在国内很少有用 UDP 作为底层传输协议的。UDP 虽然传输快，但不可靠，尤其是在用户的网络质量很差的情况下，基本无法保障音视频的服务质量。&lt;/p&gt;
&lt;p&gt;当时能想到的解决方案是，如果采用 UDP 作为底层传输协议，那就使用 RUDP（可靠性 UDP），只有这样才能保障传输过程中不丢包。但有人提出反对意见，认为如果想不丢包，就该使用 TCP，因为 RUDP 可靠性做到极致就变成 TCP 了，那为什么不直接使用 TCP 呢？&lt;/p&gt;
&lt;p&gt;面对这种情况，2019 年的你会做何种选择呢？UDP 还是 TCP？你能拿出让人真正信服的理由吗？&lt;/p&gt;
&lt;p&gt;现在让我告诉你正确答案：&lt;strong&gt;必须使用 UDP，必须使用 UDP，必须使用 UDP&lt;/strong&gt;，重要的事情说三遍。&lt;/p&gt;
    
    </summary>
    
      <category term="WebRTC" scheme="http://xiaolong.li/categories/WebRTC/"/>
    
    
      <category term="RTP" scheme="http://xiaolong.li/tags/RTP/"/>
    
      <category term="RTCP" scheme="http://xiaolong.li/tags/RTCP/"/>
    
      <category term="WebRTC" scheme="http://xiaolong.li/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>正向代理和反向代理的区别</title>
    <link href="http://xiaolong.li/2021/02/19/The-difference-between-forward-and-reverse-proxy/"/>
    <id>http://xiaolong.li/2021/02/19/The-difference-between-forward-and-reverse-proxy/</id>
    <published>2021-02-19T05:32:50.000Z</published>
    <updated>2021-08-31T11:28:25.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="什么是代理服务器？"><a href="#什么是代理服务器？" class="headerlink" title="什么是代理服务器？"></a>什么是代理服务器？</h4><p>所谓代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。</p><a id="more"></a><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理（Forward Proxy）类似一个跳板机，代理访问外部资源</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了</p><p><img src="/images/network/2021-02-19-forward-proxy.jpg" alt="image" title="正向代理"></p><h5 id="正向代理的用途"><a href="#正向代理的用途" class="headerlink" title="正向代理的用途"></a>正向代理的用途</h5><blockquote><p>（1）访问原来无法访问的资源，如google</p><p>（2）可以做缓存，加速访问资源</p><p>（3）对客户端访问授权，上网进行认证</p><p>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p></blockquote><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><p><img src="/images/network/2021-02-19-reverse-proxy.jpg" alt="image" title="反向代理"></p><h5 id="反向代理的作用"><a href="#反向代理的作用" class="headerlink" title="反向代理的作用"></a>反向代理的作用</h5><blockquote><p>（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网</p><p>（2）负载均衡，通过反向代理服务器来优化网站的负载</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote class="blockquote-center"><p>正向代理即是客户端代理，代理客户端，服务端不知道实际发起请求的客户端</p><p>反向代理即是服务端代理，代理服务端，客户端不知道实际提供服务的服务端</p></blockquote><p>正向代理中，proxy 和 client 同属一个 LAN，对 server 透明<br>反向代理中，proxy 和 server 同属一个 LAN，对 client 透明</p><p>实际上 proxy 在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是代理服务器？&quot;&gt;&lt;a href=&quot;#什么是代理服务器？&quot; class=&quot;headerlink&quot; title=&quot;什么是代理服务器？&quot;&gt;&lt;/a&gt;什么是代理服务器？&lt;/h4&gt;&lt;p&gt;所谓代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="正向代理" scheme="http://xiaolong.li/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="反向代理" scheme="http://xiaolong.li/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="Nginx" scheme="http://xiaolong.li/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux国内各大源站</title>
    <link href="http://xiaolong.li/2021/01/18/internal-linux-mirrors-website/"/>
    <id>http://xiaolong.li/2021/01/18/internal-linux-mirrors-website/</id>
    <published>2021-01-18T02:14:49.000Z</published>
    <updated>2021-08-15T16:16:16.960Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="企业源："><a href="#企业源：" class="headerlink" title="企业源："></a>企业源：</h5><p>阿里云开源镜像站： <a href="http://mirrors.aliyun.com/" target="_blank" rel="noopener">http://mirrors.aliyun.com/</a><br>搜狐开源镜像站：<a href="http://mirrors.sohu.com/" target="_blank" rel="noopener">http://mirrors.sohu.com/</a><br>网易开源镜像站：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></p><a id="more"></a><h5 id="教育源："><a href="#教育源：" class="headerlink" title="教育源："></a>教育源：</h5><p>重庆大学：<br><a href="http://mirrors.cqu.edu.cn/" target="_blank" rel="noopener">http://mirrors.cqu.edu.cn/</a><br>北京理工大学：<br><a href="http://mirror.bit.edu.cn" target="_blank" rel="noopener">http://mirror.bit.edu.cn</a> (IPv4 only)<br><a href="http://mirror.bit6.edu.cn" target="_blank" rel="noopener">http://mirror.bit6.edu.cn</a> (IPv6 only)<br>北京交通大学：<br><a href="http://mirror.bjtu.edu.cn" target="_blank" rel="noopener">http://mirror.bjtu.edu.cn</a> (IPv4 only)<br><a href="http://mirror6.bjtu.edu.cn" target="_blank" rel="noopener">http://mirror6.bjtu.edu.cn</a> (IPv6 only)<br><a href="http://debian.bjtu.edu.cn" target="_blank" rel="noopener">http://debian.bjtu.edu.cn</a> (IPv4+IPv6)<br>兰州大学：<a href="http://mirror.lzu.edu.cn/" target="_blank" rel="noopener">http://mirror.lzu.edu.cn/</a><br>厦门大学：<a href="http://mirrors.xmu.edu.cn/" target="_blank" rel="noopener">http://mirrors.xmu.edu.cn/</a><br>上海交通大学：<br><a href="http://ftp.sjtu.edu.cn/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/</a> (IPv4 only)<br><a href="http://ftp6.sjtu.edu.cn" target="_blank" rel="noopener">http://ftp6.sjtu.edu.cn</a> (IPv6 only)<br>清华大学：<br><a href="http://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors.6.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.6.tuna.tsinghua.edu.cn/</a> (IPv6 only)<br><a href="http://mirrors.4.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.4.tuna.tsinghua.edu.cn/</a> (IPv4 only)<br>天津大学：<a href="http://mirror.tju.edu.cn/" target="_blank" rel="noopener">http://mirror.tju.edu.cn/</a><br>中国科学技术大学：<br><a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors4.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors4.ustc.edu.cn/</a><br><a href="http://mirrors6.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors6.ustc.edu.cn/</a><br>西南大学：<a href="http://linux.swu.edu.cn/swudownload/Distributions/" target="_blank" rel="noopener">http://linux.swu.edu.cn/swudownload/Distributions/</a><br>东北大学：<br><a href="http://mirror.neu.edu.cn/" target="_blank" rel="noopener">http://mirror.neu.edu.cn/</a> (IPv4 only)<br><a href="http://mirror.neu6.edu.cn/" target="_blank" rel="noopener">http://mirror.neu6.edu.cn/</a> (IPv6 only)<br>电子科技大学：<a href="http://ubuntu.uestc.edu.cn/" target="_blank" rel="noopener">http://ubuntu.uestc.edu.cn/</a><br>青岛大学：<a href="http://mirror.qdu.edu.cn/" target="_blank" rel="noopener">http://mirror.qdu.edu.cn/</a><br>开源中国社区 <a href="http://mirrors.oss.org.cn/" target="_blank" rel="noopener">http://mirrors.oss.org.cn/</a><br>大连东软信息学院 <a href="http://mirrors.neusoft.edu.cn/" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/</a><br>华中科技大学 <a href="http://mirrors.hust.edu.cn/" target="_blank" rel="noopener">http://mirrors.hust.edu.cn/</a><br>中山大学 <a href="http://mirrors.sysu.edu.cn/" target="_blank" rel="noopener">http://mirrors.sysu.edu.cn/</a><br>清华大学学生网管会 <a href="http://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/</a><br>浙江大学 <a href="http://mirrors.zju.edu.cn/web/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/web/</a></p><p>台湾淡江大学 <a href="http://ftp.tku.edu.tw/Linux/" target="_blank" rel="noopener">http://ftp.tku.edu.tw/Linux/</a></p><p>Linux运维派开源镜像 <a href="http://mirrors.skyshe.cn/" target="_blank" rel="noopener">http://mirrors.skyshe.cn/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;企业源：&quot;&gt;&lt;a href=&quot;#企业源：&quot; class=&quot;headerlink&quot; title=&quot;企业源：&quot;&gt;&lt;/a&gt;企业源：&lt;/h5&gt;&lt;p&gt;阿里云开源镜像站： &lt;a href=&quot;http://mirrors.aliyun.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.aliyun.com/&lt;/a&gt;&lt;br&gt;搜狐开源镜像站：&lt;a href=&quot;http://mirrors.sohu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.sohu.com/&lt;/a&gt;&lt;br&gt;网易开源镜像站：&lt;a href=&quot;http://mirrors.163.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.163.com/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kafka-Cluster-building</title>
    <link href="http://xiaolong.li/2020/11/11/Kafka-Cluster-building/"/>
    <id>http://xiaolong.li/2020/11/11/Kafka-Cluster-building/</id>
    <published>2020-11-11T11:06:08.000Z</published>
    <updated>2021-08-07T16:32:49.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://cloud.tencent.com/developer/article/1023898" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1023898</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>zookeeper集群搭建</title>
    <link href="http://xiaolong.li/2020/11/11/Zookeeper-Cluster-building/"/>
    <id>http://xiaolong.li/2020/11/11/Zookeeper-Cluster-building/</id>
    <published>2020-11-11T11:05:30.000Z</published>
    <updated>2021-08-07T16:32:49.024Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="为什么-zookeeper-集群的节点数是奇数"><a href="#为什么-zookeeper-集群的节点数是奇数" class="headerlink" title="为什么 zookeeper 集群的节点数是奇数"></a>为什么 zookeeper 集群的节点数是奇数</h4><p>zookeeper 集群通常是用来对用户的分布式应用程序提供协调服务的，为了保证数据的一致性，对 zookeeper 集群进行了这样三种角色划分：leader、follower、observer分别对应着主、从、观察者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leader : 负责进行投票的发起和决议，更新系统状态。</span><br><span class="line">follower : 用于接收客户端请求并向客户端返回结果以及在选举过程中参与投票。</span><br><span class="line">observer : 通常是针对于查询操作做负载的。 observer 与 follower 节点最大的不同在于 observer 没有投票权，在客户端发起的增删改操中， leader 节点是不会把消息传递给 observer 让其投票的。但是查询操作跟 follower 一样，客户端的查询到了 observer 节点， observer 节点会去访问 leader 节点取最新的数据然后返回给客户端。</span><br></pre></td></tr></table></figure><p>集群可以保证在每台机器数据保持一致的情况下，客户端每次发起的查询操作，集群节点都能返回同样的结果。但是对于客户端发起的增、删、改等能改变数据的操作，如果集群中的多台机器各自修改数据，那么就无法保证数据的一致性。</p><p>那么，对于增、删、改操作， zookeeper 集群规定只有 leader 节点才有权利去执行修改数据的操作，而 follower 节点即使接收到客户端发起的数据修改操作，也要将其转交给 leader 来处理， leader节点接收到修改数据的请求后，会向所有 follower 节点广播一条消息，让其执行操作， follower 节点执行完后，需要向 leader 节点回复执行结果。当 leader 节点收到半数以上的 follower 节点的确认消息后，便会判定该操作执行完毕，然后向所有 follower 节点广播该操作已经生效。</p><p>所以在 zookeeper 集群中， leader 节点是不可缺少的， leader 节点也是由所有 follower 节点选举产生，而且只有一个。</p><p>//todo leader节点选取逻辑</p><blockquote><p>zookeeper 集群中 leader 的选取逻辑，要求 <strong>可用节点数量</strong> &gt; <strong>总节点数量 / 2</strong>，注意，这里是 <strong>&gt;</strong> ,并非 <strong>&gt;=</strong> 。 </p></blockquote><p>为什么集群节点数量要奇数个，主要从以下两个方面考虑。</p><h5 id="防脑裂导致集群不可用"><a href="#防脑裂导致集群不可用" class="headerlink" title="防脑裂导致集群不可用"></a>防脑裂导致集群不可用</h5><p>在一个 zookeeper 集群中，可以有多个 follower 和 observe 节点，但是有且只能有一个 leader 节点。如果 leader 节点不可用或者宕机，剩下的所有节点机器会投票产生新的 leader 节点。</p><p>集群脑裂: 一个集群由于网络不通或者其他原因分裂成多个小集群的现象。</p><h5 id="容错率和成本控制"><a href="#容错率和成本控制" class="headerlink" title="容错率和成本控制"></a>容错率和成本控制</h5><p><a href="https://www.cnblogs.com/lishiqi-blog/p/12314111.html" target="_blank" rel="noopener">https://www.cnblogs.com/lishiqi-blog/p/12314111.html</a></p><p><a href="https://www.cnblogs.com/ysocean/p/9860529.html" target="_blank" rel="noopener">https://www.cnblogs.com/ysocean/p/9860529.html</a></p><p><a href="https://blog.csdn.net/jiangxiulilinux/article/details/96433560" target="_blank" rel="noopener">https://blog.csdn.net/jiangxiulilinux/article/details/96433560</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="教程" scheme="http://xiaolong.li/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="zookeeper" scheme="http://xiaolong.li/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Introduction-to-h264-frame</title>
    <link href="http://xiaolong.li/2020/10/21/Introduction-to-h264-frame/"/>
    <id>http://xiaolong.li/2020/10/21/Introduction-to-h264-frame/</id>
    <published>2020-10-21T02:29:01.000Z</published>
    <updated>2021-08-07T16:32:49.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>同城双中心容灾简介及部署网络</title>
    <link href="http://xiaolong.li/2020/03/04/Introduction-to-Dual-Center-for-Disaster-Recovery/"/>
    <id>http://xiaolong.li/2020/03/04/Introduction-to-Dual-Center-for-Disaster-Recovery/</id>
    <published>2020-03-04T08:53:09.000Z</published>
    <updated>2021-08-07T16:32:49.020Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>同城双中心是指在同城或邻近城市建立两个可独立承担业务的数据中心，双中心具备基本相同的业务处理能力并通过高速链路实时同步数据，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下备应急切换，保证业务的持续性。异地灾备中心是指在异地的城市建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。</p><p>同城双中心的部署方式分为两种，分别为主备和双活。</p><a id="more"></a><h3 id="主备中心模型"><a href="#主备中心模型" class="headerlink" title="主备中心模型"></a>主备中心模型</h3><p>从字面含义上看，主备中心就是建设两个数据中心，一主一备，两个数据中心均具有独立承担对外提供业务的能力。正常情况下，主中心对外提供服务，当重大故障发生时，主中心的业务切换到备中心，备中心成为新的生产中心对外提供服务。</p><p>以上对主备关系的描述非常简单，但在实际部署过程中，需网络、应用、数据库等多部门协调合作，才能切换，我们今天主要谈网络。</p><h4 id="主备数据中心示意图"><a href="#主备数据中心示意图" class="headerlink" title="主备数据中心示意图"></a>主备数据中心示意图</h4><p>上图是较为典型的同城主备中心网络模型，A中心是生产中心，B中心为备中心，A、B两个中心的业务分区使用相同的IP地址段。</p><h4 id="技术关键点："><a href="#技术关键点：" class="headerlink" title="技术关键点："></a>技术关键点：</h4><blockquote><ol><li>A、B中心的网络核心（网关）进行二层打通；</li><li>网关启用在主中心一侧，备中心网关为关闭状态；</li><li>主中心A对外发布路由,B中心不对外发布路由。</li></ol></blockquote><h4 id="数据中心间切换"><a href="#数据中心间切换" class="headerlink" title="数据中心间切换"></a>数据中心间切换</h4><p>A中心停止对外发布路由,B中心，同时将A中心的网关切换至B中心，这样就完成了数据中心网络的切换。</p><h4 id="主备模型优点"><a href="#主备模型优点" class="headerlink" title="主备模型优点"></a>主备模型优点</h4><blockquote><ol><li>技术简单、切换方便；</li><li>现有双中心过渡到此模型较简单，不涉及应用IP地址改造；</li></ol></blockquote><h4 id="主备模型缺点"><a href="#主备模型缺点" class="headerlink" title="主备模型缺点"></a>主备模型缺点</h4><blockquote><ol><li>存在较多的中心间穿越流量，无法做到“本中心服务器从本中心出入”（两侧网关无法同时开启，否则会出现防火墙异步路由问题）。</li><li>中心间的物理距离过长，导致网络延迟增大，对延时敏感的应用可能会受到影响；</li><li>中心间L2打通，会使二层域扩大，一个中心二层故障可能影响到另一个中心，需做数据中心STP隔离或采用特殊技术，例如OTV；</li><li>需考虑防火墙策略如何同步的问题；</li><li>链路闲置，资源没有得到最大化利用，例如B中心对外的广域网链路。</li></ol></blockquote><h3 id="双活中心模型"><a href="#双活中心模型" class="headerlink" title="双活中心模型"></a>双活中心模型</h3><h4 id="双活中心示意图"><a href="#双活中心示意图" class="headerlink" title="双活中心示意图"></a>双活中心示意图</h4><p>双活数据中心，即两个数据中心具有同时对外提供服务的能力。如下图：</p><p>A、B两个数据中心，采用独立的IP地址段，同时对外提供服务，客户端依靠DNS的解析结果，来判断从哪个数据中心进入。</p><h4 id="技术关键点"><a href="#技术关键点" class="headerlink" title="技术关键点"></a>技术关键点</h4><blockquote><ol><li>两个中心采用独立的IP地址段，均对外发布路由；</li><li>采用DNS的方式，将客户端流量引至对应数据中心。</li></ol></blockquote><h4 id="数据中心切换"><a href="#数据中心切换" class="headerlink" title="数据中心切换"></a>数据中心切换</h4><blockquote><ol><li>正常情况下，两个数据中心同时对外提供服务；</li><li>一侧数据中心故障时，改变DNS解析，即可停止该数据中心的服务。</li></ol></blockquote><h4 id="双活数据中心优点"><a href="#双活数据中心优点" class="headerlink" title="双活数据中心优点"></a>双活数据中心优点</h4><blockquote><ol><li>两个数据中心完全独立，互不干扰；</li><li>数据中心间流量较少；</li><li>无需考虑防火墙异步路由问题；</li><li>链路得到更有效的利用，经济最大化。</li></ol></blockquote><h4 id="双活数据中心缺点"><a href="#双活数据中心缺点" class="headerlink" title="双活数据中心缺点"></a>双活数据中心缺点</h4><p>技术方面，暂时没有想到缺点。可行性上，从现有双中心过渡到双活数据中心，除IP地址改造外，还涉及应用的DNS改造，涉及部门间协同工作，驱动困难，这种模型较适合新建的数据中心。</p><p>选择数据中心网络模型，需调研业务/应用/系统/服务器的部署需求，从上到下统一考虑，最适合自己的，才是最好的。</p><p><strong><em> 无论是主备还是双活，网络层面做到各种“活”并不困难，在生产环境中，目前面临的最大瓶颈其实是双中心的数据库的“双活”问题。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同城双中心是指在同城或邻近城市建立两个可独立承担业务的数据中心，双中心具备基本相同的业务处理能力并通过高速链路实时同步数据，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下备应急切换，保证业务的持续性。异地灾备中心是指在异地的城市建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。&lt;/p&gt;
&lt;p&gt;同城双中心的部署方式分为两种，分别为主备和双活。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://xiaolong.li/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="容灾" scheme="http://xiaolong.li/tags/%E5%AE%B9%E7%81%BE/"/>
    
  </entry>
  
  <entry>
    <title>gRpc-go流模式中，服务端如何主动关闭stream</title>
    <link href="http://xiaolong.li/2020/03/02/How-to-cancel-streaming-gRPC-Send-from-server/"/>
    <id>http://xiaolong.li/2020/03/02/How-to-cancel-streaming-gRPC-Send-from-server/</id>
    <published>2020-03-02T13:19:24.000Z</published>
    <updated>2021-08-07T16:32:49.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用gRpc流模式的过程中会发现，官方API只提供了客户端关闭stream的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CloseSend closes the send direction of the stream. It closes the stream</span></span><br><span class="line"><span class="comment">// when non-nil error is met. It is also not safe to call CloseSend</span></span><br><span class="line"><span class="comment">// concurrently with SendMsg.</span></span><br><span class="line">CloseSend() error</span><br></pre></td></tr></table></figure><blockquote><p>那么在开发过程中我们是不是需要从服务端主动断开stream，如果需要，该怎么断开？</p></blockquote><a id="more"></a><p>如果你知道gRpc的底层原理，其实很好理解为什么官方不提供服务端断开的API。因为gRpc底层是通过TCP实现的 [事实上，基本上所有RPC框架默认都是使用TCP，因为RPC常用在业务系统之间进行数据交换，需要保证可靠性] ，TCP的连接建立 [三次握手] 与释放 [四次挥手] 都是由客户端发起的，所以这就是为什么服务端不支持主动断开API的原因。</p><p>但是在实际开发过程中，我们经常会遇到需要服务端主动断开的策略，如果客户端出现连接泄漏的问题，通过TCP一直连接服务端，那么势必会造成服务端的连接过多无法释放，内存上升甚至出现服务宕机的危险。</p><p>那么在开发过程中就要考虑到避免因为客户端的bug导致服务器不可用，服务端就需要有保护机制。</p><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>服务端流式的设计，需要在发送给客户端响应时告知客户端，服务端已经处理完了，就是最后一帧的概念，多久以后服务端还没有收到客户端断开的标志，那么服务断就主动发起断开。所以一般服务端流式要做到以下两点：</p><blockquote><ol><li>流结束标志</li><li>定时器（最重要）</li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong><em>Talk is cheap, Show me the code.</em></strong></p><p>proto协议设计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package protocol;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    string  msg     =   1;</span><br><span class="line">    int32   times   =   2;</span><br><span class="line">    bool    last    =   3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    string  reply   =   1;</span><br><span class="line">    int32   index   =   2;</span><br><span class="line">    bool    last    =   3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service KeJiInterface &#123;</span><br><span class="line">    rpc Say(stream Request) returns (stream Response) &#123;&#125;</span><br><span class="line">    rpc ServerStream(Request) returns (stream Response) &#123;&#125;</span><br><span class="line">    rpc ClientStream(stream Request) returns (Response) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双向流"><a href="#双向流" class="headerlink" title="双向流"></a>双向流</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="服务端单向流式"><a href="#服务端单向流式" class="headerlink" title="服务端单向流式"></a>服务端单向流式</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用gRpc流模式的过程中会发现，官方API只提供了客户端关闭stream的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// CloseSend closes the send direction of the stream. It closes the stream&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// when non-nil error is met. It is also not safe to call CloseSend&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// concurrently with SendMsg.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CloseSend() error&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;那么在开发过程中我们是不是需要从服务端主动断开stream，如果需要，该怎么断开？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="教程" scheme="http://xiaolong.li/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="gRpc" scheme="http://xiaolong.li/tags/gRpc/"/>
    
      <category term="RPC" scheme="http://xiaolong.li/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>你必须知道的Docker镜像仓库的搭建</title>
    <link href="http://xiaolong.li/2020/02/13/Introduction-docker-repository-setup/"/>
    <id>http://xiaolong.li/2020/02/13/Introduction-docker-repository-setup/</id>
    <published>2020-02-13T12:58:39.000Z</published>
    <updated>2021-08-07T16:32:49.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="官方标配：Registry私有镜像仓库"><a href="#官方标配：Registry私有镜像仓库" class="headerlink" title="官方标配：Registry私有镜像仓库"></a>官方标配：Registry私有镜像仓库</h4><p><a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a> 作为 Docker 默认官方公共镜像，如果想要自己搭建私有镜像残酷，官方也提供 Registry 镜像，使得我们搭建私有仓库变得非常简单。</p><p>所谓私有仓库，也就是在本地（局域网）搭建的一个类似公共仓库的东西，搭建好之后，我们可以将镜像提交到私有仓库中。这样我们既能使用 Docker 来运行我们的项目镜像，也避免了商业项目暴露出去的风险。</p><a id="more"></a><h5 id="搭建镜像仓库"><a href="#搭建镜像仓库" class="headerlink" title="搭建镜像仓库"></a>搭建镜像仓库</h5><p>首先，搜索 Registry 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search registry</span><br></pre></td></tr></table></figure><p><img src="/images/docker/2020-02-13-docker-search-registry.jpg" alt="image" title="Docker搜索registry镜像"></p><p>下载 Registry 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><p><img src="/images/docker/2020-02-13-docker-pull-registry.jpg" alt="image" title="Docker拉取registry拉取"></p><p>查看本地镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/images/docker/2020-02-13-docker-images.jpg" alt="image" title="查看本地镜像"></p><p>运行一个Registry镜像仓库的容器实例，检查是否启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry registry:latest</span><br></pre></td></tr></table></figure><p>最后，在客户端查看镜像仓库中的所有镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://your-server-ip:5000/v2/_catalog</span><br></pre></td></tr></table></figure><p><img src="/images/docker/2020-02-13-docker-registry-images-null-list.jpg" alt="image" title="查看仓库镜像列表"></p><p>这里返回的json数据代表暂无任何仓库，因为我们还没有上传任何镜像。</p><h5 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push your-image-name:tagname your-server-ip:5000/your-image-name:tagname</span><br></pre></td></tr></table></figure><blockquote><p>如果不设置可信任源，又没有配置HTTPS证书，那么会遇到这个错误：error: Get <a href="https://ip:port/v1/_ping" target="_blank" rel="noopener">https://ip:port/v1/_ping</a>: http: server gave HTTP response to HTTPS client.</p></blockquote><h5 id="设置可信任源"><a href="#设置可信任源" class="headerlink" title="设置可信任源"></a>设置可信任源</h5><h5 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h5><p>下载镜像就很简单了，使用pull命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull your-server-ip:5000/your-image-name:tagname</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;官方标配：Registry私有镜像仓库&quot;&gt;&lt;a href=&quot;#官方标配：Registry私有镜像仓库&quot; class=&quot;headerlink&quot; title=&quot;官方标配：Registry私有镜像仓库&quot;&gt;&lt;/a&gt;官方标配：Registry私有镜像仓库&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://hub.docker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker Hub&lt;/a&gt; 作为 Docker 默认官方公共镜像，如果想要自己搭建私有镜像残酷，官方也提供 Registry 镜像，使得我们搭建私有仓库变得非常简单。&lt;/p&gt;
&lt;p&gt;所谓私有仓库，也就是在本地（局域网）搭建的一个类似公共仓库的东西，搭建好之后，我们可以将镜像提交到私有仓库中。这样我们既能使用 Docker 来运行我们的项目镜像，也避免了商业项目暴露出去的风险。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://xiaolong.li/tags/Docker/"/>
    
      <category term="Docker Hub" scheme="http://xiaolong.li/tags/Docker-Hub/"/>
    
      <category term="Docker Registry" scheme="http://xiaolong.li/tags/Docker-Registry/"/>
    
  </entry>
  
  <entry>
    <title>最佳实践之 - Golang&#39;s Dockerfile</title>
    <link href="http://xiaolong.li/2020/02/13/Dockerfile-best-practices-for-golang-projects/"/>
    <id>http://xiaolong.li/2020/02/13/Dockerfile-best-practices-for-golang-projects/</id>
    <published>2020-02-13T12:58:39.000Z</published>
    <updated>2021-08-07T16:32:49.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="常用做法"><a href="#常用做法" class="headerlink" title="常用做法"></a>常用做法</h4><p>基于 golang 官方基础镜像打包，Dockerfile如下：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 golang 官方基础镜像打包</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.12</span></span><br><span class="line"></span><br><span class="line">NV GO111MODULE=on \</span><br><span class="line">    GOPROXY=https://goproxy.cn,direct </span><br><span class="line">    </span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> . .</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> go build .</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["./app"]</span><br></pre></td></tr></table></figure></p><p>但是最终 docker build 出来的镜像高达300多M, 这是由于 golang 这个基础镜像中的工具链及其依赖项（git，mercurial 等）重达几百MB，而这一部分我们在运行的时候是不需要的。</p><p>因此，我们需要对基础镜像进行精简。</p><a id="more"></a><h4 id="精简镜像"><a href="#精简镜像" class="headerlink" title="精简镜像"></a>精简镜像</h4><h5 id="使用-scratch"><a href="#使用-scratch" class="headerlink" title="使用 scratch"></a>使用 scratch</h5><p>该镜像是一个空的镜像，可以用于构建 busybox 等超小镜像，可以说是真正的从零开始构建属于自己的镜像。在此基础镜像上运行的应用程序只能访问内核，尽管Go宣称自己只需要Linux内核，但是我们在真实的项目中或多或少会有其他依赖项，比如 我们项目会用到 CGO 等等。所以在构建 Golang 项目是，一般不建议直接采用 scratch 做基础镜像，否则你需要在 Dockerfile 中手动加载很多依赖项。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 scratch 官方基础镜像打包</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br></pre></td></tr></table></figure><h5 id="使用-alpine"><a href="#使用-alpine" class="headerlink" title="使用 alpine"></a>使用 alpine</h5><p>Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，alpine 采用了 musl libc 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。</p><p>Alpine Docker 镜像也继承了 Alpine Linux 发行版的这些优势。相比于其他 Docker 镜像，它的容量非常小，仅仅只有 5 MB 左右（对比 Ubuntu 系列镜像接近 200 MB），且拥有非常友好的包管理机制。官方镜像来自 docker-alpine 项目。目前 Docker 官方已开始推荐使用 Alpine 替代之前的 Ubuntu 做为基础镜像环境。</p><p>Alpine 和其他通用 Linux 发行版对于 Golang 编译出来的可执行文件要求有所不同，Alpine 要求可执行文件必须是静态链接的可执行文件。所以在编译 Golang 时需要添加 -tags netgo ，来生成静态链接的可执行文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 alpine 官方基础镜像打包</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br></pre></td></tr></table></figure><p>但是对 C 的支持不太好。</p><p>在 Alpine Docker 镜像上运行 cgo 项目会出现问题，提示一下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: standard_init_linux.go:175: exec user process caused &quot;no such file or directory&quot;</span><br></pre></td></tr></table></figure></p><p>原因是当 cgo 开启时，默认是按照动态库的方式来链接 so 文件的，但 alpine 只支持静态链接，所以会出错。<br>解决方案有两种：</p><blockquote><p>通过设置 CGO_ENABLED=0 来解决，此时 cgo 也不可用了</p></blockquote><blockquote><p>调用 go build –ldflags “-extldflags -static” ，来让gcc使用静态编译可以解决问题</p></blockquote><h5 id="使用-ubuntu"><a href="#使用-ubuntu" class="headerlink" title="使用 ubuntu"></a>使用 ubuntu</h5><p>ubuntu 镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 ubuntu 官方基础镜像打包</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br></pre></td></tr></table></figure><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h5 id="多层构建方式"><a href="#多层构建方式" class="headerlink" title="多层构建方式"></a>多层构建方式</h5><blockquote><p>FROM golang:1.12<br>用对go功能比较齐全镜像编译源程序，生成可执行文件</p></blockquote><blockquote><p>FROM ubuntu<br>用精简镜像作为最终的容器的镜像</p></blockquote><blockquote><p>拷贝可执行文件到容器内</p></blockquote><blockquote><p>打包生成最终的镜像</p></blockquote><p>Dockerfile:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包依赖阶段使用golang作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.12</span> as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span> version="1.0" description="xiaolong.li" by="xiaolonghuster"</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用go module</span></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on \</span><br><span class="line">    GOPROXY=https://goproxy.cn,direct</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /app-pkg</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> . /app-pkg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定OS等，并go build</span></span><br><span class="line"><span class="keyword">RUN</span> GOOS=linux GOARCH=amd64 &amp;&amp; cd src &amp;&amp; go build -o app main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于不止依赖二进制文件，还依赖conf文件夹下的配置文件，将这些文件放到了publish文件夹</span></span><br><span class="line"><span class="keyword">RUN</span> mkdir publish &amp;&amp; cp src/app publish &amp;&amp; \</span><br><span class="line">    cp -r conf publish</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行阶段为精简镜像包，指定ubuntu作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上一个阶段publish文件夹下的所有文件复制进来</span></span><br><span class="line"><span class="keyword">COPY</span> --from=builder /app-pkg/publish .</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10086</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["./app"]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;常用做法&quot;&gt;&lt;a href=&quot;#常用做法&quot; class=&quot;headerlink&quot; title=&quot;常用做法&quot;&gt;&lt;/a&gt;常用做法&lt;/h4&gt;&lt;p&gt;基于 golang 官方基础镜像打包，Dockerfile如下：&lt;br&gt;&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 基于 golang 官方基础镜像打包&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; golang:&lt;span class=&quot;number&quot;&gt;1.12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NV GO111MODULE=on \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GOPROXY=https://goproxy.cn,direct &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WORKDIR&lt;/span&gt; /app&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;COPY&lt;/span&gt; . .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; go build .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;EXPOSE&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10010&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENTRYPOINT&lt;/span&gt; [&quot;./app&quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是最终 docker build 出来的镜像高达300多M, 这是由于 golang 这个基础镜像中的工具链及其依赖项（git，mercurial 等）重达几百MB，而这一部分我们在运行的时候是不需要的。&lt;/p&gt;
&lt;p&gt;因此，我们需要对基础镜像进行精简。&lt;/p&gt;
    
    </summary>
    
      <category term="最佳实践" scheme="http://xiaolong.li/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Dockerfile" scheme="http://xiaolong.li/tags/Dockerfile/"/>
    
      <category term="Golang" scheme="http://xiaolong.li/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>GO语言代码规范指导</title>
    <link href="http://xiaolong.li/2019/12/05/Developer-Guide-for-Golang/"/>
    <id>http://xiaolong.li/2019/12/05/Developer-Guide-for-Golang/</id>
    <published>2019-12-05T14:24:00.000Z</published>
    <updated>2021-08-07T16:32:49.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 本规范旨在为日常Go项目开发提供一个代码的规范指导，方便团队形成一个统一的代码风格，提高代码的可读性，规范性和统一性。本规范将从命名规范，注释规范，代码风格和 Go 语言提供的常用的工具这几个方面做一个说明。该规范参考了 go 语言官方代码的风格制定。</p> <a id="more"></a><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>命名是代码规范中很重要的一部分，统一的命名规则有利于提高的代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。</p><p>Go在命名时以字母a到Z或a到Z或下划线开头，后面跟着零或更多的字母、下划线和数字(0到9)。Go不允许在命名时中使用@、$和%等标点符号。Go是一种区分大小写的编程语言。因此，Manpower和manpower是两个不同的命名。</p><p>当命名（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）。<br>命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。</p><h4 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h4><p>保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为小写单词，不要使用下划线或者混合大小写。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>尽量采取有意义的文件名，简短，有意义，应该为小写单词，使用下划线分隔各个单词。</p><blockquote><p>my_test.go</p></blockquote><h4 id="结构体命名"><a href="#结构体命名" class="headerlink" title="结构体命名"></a>结构体命名</h4><p>采用驼峰命名法，首字母根据访问控制大写或者小写。</p><p>struct 申明和初始化格式采用多行，例如下面：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多行申明</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="keyword">string</span></span><br><span class="line">    Email     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 多行初始化</span></span><br><span class="line">u := User&#123;</span><br><span class="line">    Username: <span class="string">"avatar"</span>,</span><br><span class="line">    Email:    <span class="string">"avatar@gmail.com"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h4><p>命名规则基本和上面的结构体类型。</p><p>单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><ul><li>和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则： </li><li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient</li><li>其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID</li><li>错误示例：UrlArray，应该写成 urlArray 或者 URLArray</li><li>若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isExist <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> hasConflict <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> canManage <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> allowGitHook <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><h4 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h4><p>常量均需使用全部大写字母组成，并使用下划线分词。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> APP_VER = <span class="string">"1.0"</span></span><br></pre></td></tr></table></figure><p>如果是枚举类型的常量，需要先创建相应类型：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="keyword">string</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    HTTP  Scheme = <span class="string">"http"</span></span><br><span class="line">    HTTPS Scheme = <span class="string">"https"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>下面的列表显示了Go中的保留字。这些保留字不能用作常量或变量或任何其他标识符名称。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Go 提供 C 风格的块注释和 C++ 风格的行注释。行注释是常态；块注释主要显示为包注释，但在表达式中很有用或禁用大量代码。</p><ul><li>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释</li><li>多行注释也叫块注释，均已以 /<em> 开头，并以 </em>/ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是多行注释 </span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure><p>go 语言自带的 godoc 工具可以根据注释生成文档，生成可以自动生成对应的网站（ <a href="http://golang.org" target="_blank" rel="noopener">http://golang.org</a> 就是使用 godoc 工具直接生成的），注释的质量决定了生成的文档的质量。每个包都应该有一个包注释，在package子句之前有一个块注释。对于多文件包，包注释只需要存在于一个文件中，任何一个都可以。包评论应该介绍包，并提供与整个包相关的信息。它将首先出现在godoc页面上，并应设置下面的详细文档。</p><p>详细的如何写注释可以 参考：<a href="http://golang.org/doc/effective_go.html#commentary" target="_blank" rel="noopener">http://golang.org/doc/effective_go.html#commentary</a></p><h4 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a>包注释</h4><p>每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中（一般是和包同名的文件）即可。 包注释应该包含下面基本信息(请严格按照这个顺序，简介，创建人，创建时间）：</p><ul><li>包的基本简介（包名，简介）</li><li>创建者，格式： 创建人： rtx 名</li><li>创建时间，格式：创建时间： yyyyMMdd</li></ul><p>例如 util 包的注释示例如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。</span></span><br><span class="line"><span class="comment">// 创建人： xlli5</span></span><br><span class="line"><span class="comment">// 创建时间： 20190522</span></span><br></pre></td></tr></table></figure><h4 id="结构（接口）注释"><a href="#结构（接口）注释" class="headerlink" title="结构（接口）注释"></a>结构（接口）注释</h4><p>每个自定义的结构体或者接口都应该有注释说明，该注释对结构进行简要介绍，放在结构体定义的前一行，格式为： 结构体名， 结构体说明。同时结构体内的每个成员变量都要有说明，该说明放在成员变量的后面（注意对齐），实例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User ， 用户对象，定义了用户的基础信息</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="keyword">string</span> <span class="comment">// 用户名</span></span><br><span class="line">    Email     <span class="keyword">string</span> <span class="comment">// 邮箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数（方法）注释"><a href="#函数（方法）注释" class="headerlink" title="函数（方法）注释"></a>函数（方法）注释</h4><p>每个函数，或者方法（结构体或者接口下的函数称为方法）都应该有注释说明，函数的注释应该包括三个方面（严格按照此顺序撰写）：</p><ul><li>简要说明，格式说明：以函数名开头，“，”分隔说明部分</li><li>参数列表：每行一个参数，参数名开头，“，”分隔说明部分</li><li>返回值： 每行一个返回值</li></ul><p>示例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewtAttrModel ， 属性数据层操作类的工厂方法</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      ctx ： 上下文信息</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      属性操作类指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAttrModel</span><span class="params">(ctx *common.Context)</span> *<span class="title">AttrModel</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码逻辑注释"><a href="#代码逻辑注释" class="headerlink" title="代码逻辑注释"></a>代码逻辑注释</h4><p>对于一些关键位置的代码逻辑，或者局部较为复杂的逻辑，需要有相应的逻辑说明，方便其他开发者阅读该段代码，实例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br><span class="line">xxxxx</span><br><span class="line">xxxxxxx</span><br><span class="line">xxxxxxx</span><br></pre></td></tr></table></figure><h4 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h4><p>统一使用中文注释，对于中英文字符之间严格使用空格分隔， 这个不仅仅是中文和英文之间，英文和中文标点之间也都要使用空格分隔，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br></pre></td></tr></table></figure><p>上面 Redis 、 id 、 DB 和其他中文字符之间都是用了空格分隔。</p><pre><code>建议全部使用单行注释和代码的规范一样，单行注释不要过长，禁止超过 120 字符</code></pre><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><h4 id="缩进和折行"><a href="#缩进和折行" class="headerlink" title="缩进和折行"></a>缩进和折行</h4><ul><li>缩进直接使用 gofmt 工具格式化即可（gofmt 是使用 tab 缩进的）</li><li>折行方面，一行最长不超过120个字符，超过的请使用换行展示，尽量保持格式优雅</li></ul><p>我们使用Goland开发工具，可以直接使用快捷键：ctrl+alt+L，即可。</p><h4 id="语句的结尾"><a href="#语句的结尾" class="headerlink" title="语句的结尾"></a>语句的结尾</h4><p>Go语言中是不需要类似于Java需要冒号结尾，默认一行就是一条数据</p><p>如果你打算将多个语句写在同一行，它们则必须使用。</p><h4 id="括号和空格"><a href="#括号和空格" class="headerlink" title="括号和空格"></a>括号和空格</h4><p>括号和空格方面，也可以直接使用 gofmt 工具格式化（go 会强制左大括号不换行，换行会报语法错误），所有的运算符和操作数之间要留空格。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的方式</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line">​</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 错误的方式</span></span><br><span class="line"><span class="keyword">if</span> a&gt;<span class="number">0</span>  <span class="comment">// a ，0 和 &gt; 之间应该空格</span></span><br><span class="line">&#123;       <span class="comment">// 左大括号不可以换行，会报语法错误</span></span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="import-规范"><a href="#import-规范" class="headerlink" title="import 规范"></a>import 规范</h4><p>import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">​</span><br><span class="line">    <span class="string">"myproject/models"</span></span><br><span class="line">    <span class="string">"myproject/controller"</span></span><br><span class="line">    <span class="string">"myproject/utils"</span></span><br><span class="line">​</span><br><span class="line">    <span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">    <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。</p><p>在项目中不要使用相对路径引入包：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是不好的导入</span></span><br><span class="line"><span class="keyword">import</span> “../net”</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 这是正确的做法</span></span><br><span class="line"><span class="keyword">import</span> “github.com/repo/proj/src/net”</span><br></pre></td></tr></table></figure><p>但是如果是引入本项目中的其他包，最好使用相对路径。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ul><li>错误处理的原则就是不能丢弃任何有返回err的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回err，或者使用log记录下来</li><li>尽早return：一旦有错误发生，马上返回</li><li>尽量不要使用panic，除非你知道你在做什么</li><li>错误描述如果是英文必须为小写，不需要标点结尾</li><li>采用独立的错误流进行处理</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>单元测试文件名命名规范为 example_test.go 测试用例的函数名称必须以 Test 开头，例如：TestExample 每个重要的函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p>上面提到了很过规范， go 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范，</p><p>gofmt 大部分的格式问题可以通过gofmt解决， gofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。</p><p>goimport 我们强烈建议使用 goimport ，该工具在 gofmt 的基础上增加了自动删除和引入包。</p><blockquote><p>go get golang.org/x/tools/cmd/goimports</p></blockquote><p>go vet vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。</p><blockquote><p>go get golang.org/x/tools/cmd/vet</p></blockquote><p>使用如下：</p><blockquote><p>go vet .</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本规范旨在为日常Go项目开发提供一个代码的规范指导，方便团队形成一个统一的代码风格，提高代码的可读性，规范性和统一性。本规范将从命名规范，注释规范，代码风格和 Go 语言提供的常用的工具这几个方面做一个说明。该规范参考了 go 语言官方代码的风格制定。&lt;/p&gt;
    
    </summary>
    
      <category term="GO" scheme="http://xiaolong.li/categories/GO/"/>
    
    
      <category term="编码规范" scheme="http://xiaolong.li/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="golang" scheme="http://xiaolong.li/tags/golang/"/>
    
  </entry>
  
</feed>
